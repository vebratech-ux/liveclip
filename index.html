<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Monetag SDK -->
    <meta name="monetag" content="3497665da516e3ff07e356accee2d7d5">
    <title>LiveClips</title>
    <script src="https://cdn.tailwindcss.com"></script>
<script>(function(s){s.dataset.zone='10614364',s.src='https://nap5k.com/tag.min.js'})([document.documentElement, document.body].filter(Boolean).pop().appendChild(document.createElement('script')))</script>
    
    <!-- Babel: Traduce React a JS nativo en el navegador -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
     <link rel="icon" type="image/jpeg" href="https://i.postimg.cc/4xL1nYWJ/android-chrome-512x512.png">
    
    <style>
        /* Estilos críticos para móvil */
        body { 
            background-color: #000; 
            color: white; 
            overflow: hidden; 
            overscroll-behavior: none;
            font-family: 'Inter', sans-serif;
        }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .animate-spin-slow { animation: spin 4s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        /* Filtro para poner el corazón de rojo */
        .filter-red { filter: invert(27%) sepia(51%) saturate(2878%) hue-rotate(346deg) brightness(104%) contrast(97%); }
        
        /* Animación de Notificación Toast */
        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .animate-slide-down { animation: slideDown 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        
        /* Ajuste para videos en grid */
        video { object-fit: cover; }

        /* Animación de "escribiendo" */
        @keyframes typing {
            0% { opacity: 0.2; }
            50% { opacity: 1; }
            100% { opacity: 0.2; }
        }
        .typing-dot {
            display: inline-block;
            width: 6px;
            height: 6px;
            margin: 0 1px;
            background-color: #38bdf8; /* cyan-400 */
            border-radius: 50%;
            animation: typing 1.5s infinite ease-in-out;
        }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        /* Asegura que los mensajes antiguos se vean */
        .message-list-container {
            display: flex;
            flex-direction: column-reverse; /* Hace que los nuevos mensajes aparezcan abajo */
            overflow-y: auto;
            flex: 1;
            padding: 0 1rem; /* Padding horizontal */
        }
        .message-list-content {
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* space-y-3 */
            padding-top: 1rem; /* p-4 */
        }

        /* Estilos de la forma de onda de audio (simulación) */
        .waveform {
            display: flex;
            align-items: center;
            height: 30px;
            width: 150px;
            overflow: hidden;
            gap: 1px;
            opacity: 0.8;
        }
        .waveform-bar {
            width: 2px;
            background-color: white;
            border-radius: 1px;
            transition: height 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }
        .waveform.playing .waveform-bar {
            animation: bounce 0.5s infinite alternate;
        }
        @keyframes bounce {
            0% { transform: scaleY(0.5); }
            100% { transform: scaleY(1.0); }
        }
        /* Ajuste de delays para simular movimiento */
        .waveform.playing .waveform-bar:nth-child(even) { animation-delay: 0.1s; }
        .waveform.playing .waveform-bar:nth-child(3n) { animation-delay: 0.2s; }
        .waveform.playing .waveform-bar:nth-child(5n) { animation-delay: 0.3s; }
        
        /* Estilo para el Textarea */
        textarea.chat-input {
            transition: all 0.2s ease-in-out;
            min-height: 48px;
            line-height: 1.5;
            padding-top: 10px;
            padding-bottom: 10px;
        }
        /* Estilo para el botón de comentarios en el video */
        .comments-btn-bg {
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        /* Clase para el contenedor de video en chat */
        .chat-video-container {
            position: relative;
            width: 150px; /* Tamaño fijo para la miniatura */
            height: 200px;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .chat-video-play-icon {
            position: absolute;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 50%;
            padding: 10px;
        }

        /* FIX CRÍTICO PARA SCROLL SUAVE EN MÓVIL (Petición de usuario) */
        .snap-mandatory {
            scroll-snap-type: y mandatory;
            scroll-snap-stop: always;
        }
        .snap-start {
            scroll-snap-align: start;
        }
        
        /* Estilos para el GIFTS_CONFIG */
        .gift-card {
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }
        .gift-card:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5); /* blue-500 */
        }
        .gift-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback } from 'https://esm.sh/react@18.2.0';
        import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
        import { 
            Music2, Home, Search, Loader2, AlertTriangle, Copy, Play, Pause, 
            User as UserIcon, Hash, Bell, ArrowLeft, Edit3, Camera, Check, X, 
            LogOut, Lock, UserPlus, UserCheck, Send, MessageCircle, FileText, Mic, Image, CornerUpLeft, Zap, MessageSquare, Smile, Gamepad, Paperclip
        } from 'https://esm.sh/lucide-react@0.344.0';
        
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { 
            getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, 
            onAuthStateChanged, signOut, updateProfile, signInAnonymously, signInWithCustomToken 
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { 
            getFirestore, collection, doc, onSnapshot, addDoc, getDoc, setDoc, 
            updateDoc, increment, query, orderBy, deleteDoc, where, limit, serverTimestamp, getDocs, runTransaction
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        // --- CONFIGURACIÓN DE FIREBASE (ACTUALIZADA) ---
        const firebaseConfig = {
            apiKey: "AIzaSyCqOTWcQ4uOC851_-j4JBUcENkCa-9xWdE",
            authDomain: "liveclips-93af8.firebaseapp.com",
            projectId: "liveclips-93af8",
            storageBucket: "liveclips-93af8.firebasestorage.app",
            messagingSenderId: "1075447494440",
            appId: "1:1075447494440:web:471562928542e95839021d",
            measurementId: "G-0ZC5V02V76"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        // CRÍTICO: El appId debe ser consistente con la colección de artifacts.
        const appId = 'tiktok-glass-universal'; 
        
        // --- CONFIGURACIÓN DE GEMINI API ---
        const GEMINI_API_KEY = "";
        const TTS_MODEL = "gemini-2.5-flash-preview-tts";
        // GIF de racha proporcionado por el usuario
        const STREAK_GIF_URL = "https://cdn.pixabay.com/animation/2025/06/26/05/26/05-26-59-506_512.gif";
        const VERIFIED_BADGE_URL = "https://static.vecteezy.com/system/resources/thumbnails/047/309/930/small/verified-badge-profile-icon-png.png";
        // URL del logo BIT coin para mostrar balance, tomado del código de streaming
        const BIT_COIN_LOGO_URL = "https://images.pump.fun/coin-image/EU1CPckq2dRX2HXUdy7hZvhuwmx9DN3afSHL5wTopump?variant=600x600&ipfs=bafybeiekzpu4uxvcrbvzmzteiqmia3fe2ana2ttyueqgvxodlhcsbpibre&src=https%3A%F%2Fipfs.io%2Fipfs%2Fbafybeiekzpu4uxvcrbvzmzteiqmia3fe2ana2ttyueqgvxodlhcsbpibre";

        // --- LISTA DE REGALOS (GIFTS) ---
        // Precios: 10000, 50000, 1500, 25000 (asumido para el 4to), 15000, 9000, 500 BITS
        const GIFTS_CONFIG = [
            { id: 'rose', url: 'https://i.postimg.cc/pXx4XpZg/photo-2025-12-02-17-52-12-removebg-preview.png', price: 10000, name: 'Rosa de Cristal' },
            { id: 'car', url: 'https://i.postimg.cc/pL0LBNTg/image-removebg-preview-(7).png', price: 50000, name: 'Auto Deportivo' },
            { id: 'star', url: 'https://i.postimg.cc/FHbjFHTB/image-removebg-preview-(8).png', price: 1500, name: 'Estrella Fugaz' },
            { id: 'trophy', url: 'https://i.postimg.cc/y8S70DMv/image-removebg-preview-(9).png', price: 25000, name: 'Trofeo de Oro' }, 
            { id: 'house', url: 'https://i.postimg.cc/L4bdvHBC/image-removebg-preview-(10).png', price: 15000, name: 'Casa' },
            { id: 'ring', url: 'https://i.postimg.cc/g2bTBrwH/image-removebg-preview-(11).png', price: 9000, name: 'Anillo de Diamantes' },
            { id: 'heart', url: 'https://i.postimg.cc/bJS5BnRm/image-removebg-preview-(12).png', price: 500, name: 'Corazón' },
        ];


        // --- LISTA DE STICKERS (existente) ---
        const STICKERS = [
            STREAK_GIF_URL,
            "https://s3.getstickerpack.com/storage/uploads/sticker-pack/ultimate-pepe-pack-2/sticker_10.png?e3fa3504b06ce285a7dec33686b96209",
            "https://stickerly.pstatic.net/sticker_pack/GpTlbEuUtCid2gwPZCiAQ/27TIIH/16/26f3e8d8-e188-45f6-b039-4b261a354098.webp",
            "https://stickerly.pstatic.net/sticker_pack/GpTlbEuUtCid2gwPZCiAQ/27TIIH/16/af0d5379-9a85-4bd0-969f-be4ddb9f6eaf.webp",
            "https://stickerly.pstatic.net/sticker_pack/GpTlbEuUtCid2gwPZCiAQ/27TIIH/16/25abee0c-0f23-4af3-b527-f0314f89685f.webp",
            "https://stickerly.pstatic.net/sticker_pack/5I4y11Rk4vxknlhFT0J1mw/9TWCRB/61/f96c86a0-4b45-47c3-b38e-8584e74f4fcb.webp",
            "https://stickerly.pstatic.net/sticker_pack/5I4y11Rk4vxknlhFT0J1mw/9TWCRB/61/251129c4-a931-48e7-82fd-cfb94a086bb0.webp",
            "https://stickerly.pstatic.net/sticker_pack/5I4y11Rk4vxknlhFT0J1mw/9TWCRB/61/331fee66-e576-4188-90cd-de4050f9d010.webp",
            "https://s3.getstickerpack.com/storage/uploads/sticker-pack/monkeys-1/sticker_29.gif?368b8fcecd28f97edda1cff5fc55d18b"
        ];
        
        // --- CONFIGURACIÓN DE JUEGOS ---
        const GAMES_CONFIG = [
            { name: "Clash Royale", logo: "https://placehold.co/40x40/f44336/ffffff?text=CR", placeholder: "Ej: https://link.clashroyale.com/invite/friend/...", color: "bg-red-500" },
            { name: "League of Legends", logo: "https://placehold.co/40x40/03a9f4/ffffff?text=LOL", placeholder: "Ej: Código de partida de LOL", color: "bg-blue-500" },
            { name: "Among Us", logo: "https://placehold.co/40x40/4caf50/ffffff?text=AU", placeholder: "Ej: Código de sala de Among Us", color: "bg-green-500" },
            { name: "PUBG Mobile", logo: "https://placehold.co/40x40/ff9800/ffffff?text=PUBG", placeholder: "Ej: ID de sala de PUBG", color: "bg-amber-500" }
        ];


        // Función auxiliar para convertir Base64 a ArrayBuffer
        const base64ToArrayBuffer = (base64) => {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        // Función auxiliar para convertir PCM (audio) a WAV (formato reproducible)
        const pcmToWav = (pcm16, sampleRate) => {
            const numChannels = 1;
            const bytesPerSample = 2; // Int16
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcm16.byteLength;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            let offset = 0;

            // Riff Chunk
            view.setUint32(offset, 0x52494646, false); offset += 4; // "RIFF"
            view.setUint32(offset, 36 + dataSize, true); offset += 4; // ChunkSize
            view.setUint32(offset, 0x57415645, false); offset += 4; // "WAVE"

            // Fmt Chunk
            view.setUint32(offset, 0x666d7420, false); offset += 4; // "fmt "
            view.setUint32(offset, 16, true); offset += 4; // Subchunk1Size (16 for PCM)
            view.setUint16(offset, 1, true); offset += 2; // AudioFormat (1 for PCM)
            view.setUint16(offset, numChannels, true); offset += 2; // NumChannels
            view.setUint32(offset, sampleRate, true); offset += 4; // SampleRate
            view.setUint32(offset, byteRate, true); offset += 4; // ByteRate
            view.setUint16(offset, blockAlign, true); offset += 2; // BlockAlign
            view.setUint16(offset, 16, true); offset += 2; // BitsPerSample

            // Data Chunk
            view.setUint32(offset, 0x64617461, false); offset += 4; // "data"
            view.setUint32(offset, dataSize, true); offset += 4; // Subchunk2Size
            
            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }

            return new Blob([view], { type: 'audio/wav' });
        };

        const getChatId = (uid1, uid2) => [uid1, uid2].sort().join('_');

        // --- FUNCIONES AUXILIARES DE MENSAJERÍA ---
        const getUnreadMessagesCount = (chats, currentUserId) => {
            return chats.reduce((acc, chat) => {
                const otherUid = chat.participants.find(uid => uid !== currentUserId);
                const lastReadTime = chat.participantsData?.[currentUserId]?.lastRead || 0;
                if (chat.lastMessageTime && chat.lastSenderId !== currentUserId && new Date(chat.lastMessageTime).getTime() > new Date(lastReadTime).getTime()) {
                    acc++;
                }
                return acc;
            }, 0);
        };

        const getUnreadCountForChat = (chat, currentUserId) => {
             const lastReadTime = chat.participantsData?.[currentUserId]?.lastRead || 0;
             const lastMessageTime = chat.lastMessageTime ? new Date(chat.lastMessageTime).getTime() : 0;
             const isFromOtherUser = chat.lastSenderId !== currentUserId;
             const isUnread = lastMessageTime > new Date(lastReadTime).getTime();
             return isUnread && isFromOtherUser ? 1 : 0; 
        }


        // --- TUS ICONOS ORIGINALES ---
        const ICONS = {
            bandeja: "https://img.icons8.com/?size=100&id=JKQ8C03mfHVD&format=png&color=000000", // Notificación
            perfil: "https://img.icons8.com/?size=100&id=AaFA8C8mpiZY&format=png&color=000000", // Perfil
            corazon: "https://img.icons8.com/?size=100&id=sSZiheZL0ozl&format=png&color=000000", // Corazón
            tendencia: "https://img.icons8.com/?size=100&id=g8O1NN7oS0KJ&format=png&color=000000", // Tendencia
            compartir: "https://img.icons8.com/?size=100&id=Wv2O2Ve44Are&format=png&color=000000", // Compartir
            crear: "https://img.icons8.com/?size=100&id=rrOG2bhnvx0w&format=png&color=000000", // Crear
            reply: (props) => <CornerUpLeft {...props} />,
        };
        
        const VerifiedBadge = ({ size = 18 }) => (
            <img 
                src={VERIFIED_BADGE_URL} 
                className="inline-block" 
                style={{ width: size, height: size }} 
                alt="Verificado"
            />
        );

        // --- FUNCION PARA SUBIR ARCHIVOS A GITHUB ---
        const uploadToGitHub = async (file, path, setStatus) => {
            const configRef = doc(db, 'artifacts', appId, 'public', 'data', 'config', 'github');
            const configSnap = await getDoc(configRef);
            if (!configSnap.exists()) throw new Error("Falta configuración GitHub");
            const { token, owner, repo } = configSnap.data();
            
            const toBase64 = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
            });
            const content = await toBase64(file);
            
            const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                method: 'PUT',
                headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: `Upload ${path}`, content: content, encoding: 'base64' })
            });
            if (!response.ok) {
                const errorBody = await response.json();
                 throw new Error(`Error GitHub: ${errorBody.message || response.statusText}`);
            }
            
            return `https://raw.githubusercontent.com/${owner}/${repo}/main/${path}`;
        };

        // --- HOOK: Buscar Perfil Unificado por UID ---
        const useUnifiedProfile = (uid) => {
            const [profile, setProfile] = useState(null);
            
            useEffect(() => {
                if (!uid) return;
                
                // Buscamos en la colección raíz 'users' donde 'authUid' coincide
                const q = query(collection(db, "users"), where("authUid", "==", uid), limit(1));
                
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    if (!snapshot.empty) {
                        const userDoc = snapshot.docs[0];
                        // Importante: Guardamos el ID del documento (la wallet)
                        setProfile({ id: userDoc.id, ...userDoc.data() });
                    } else {
                        setProfile(null);
                    }
                });
                
                return () => unsubscribe();
            }, [uid]);
            
            return profile;
        };

        // --- COMPONENTE AUDIO PLAYER ---
        const AudioMessage = ({ audioUrl, isMe, onGeneration, text }) => {
            const audioRef = useRef(null); // Usamos ref para el elemento <audio> del DOM
            const [isPlaying, setIsPlaying] = useState(false);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            
            const needsTTS = !audioUrl && text?.length > 100;

            // Simulación de la forma de onda
            const bars = Array(15).fill(0).map((_, i) => (
                <div key={i} className="waveform-bar" style={{height: `${Math.random() * 80 + 20}%`}}></div>
            ));

            // EFECTO: Generar audio TTS si es necesario (Sin cambios)
            useEffect(() => {
                if (audioUrl || !needsTTS) return;
                const generateAndSetAudio = async () => {
                    setIsLoading(true);
                    setError(null);
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ contents: [{ parts: [{ text: `Di esto con voz alegre y clara: ${text}` }] }], generationConfig: { responseModalities: ["AUDIO"], speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Puck" } } } } })
                        });
                        if (!response.ok) throw new Error("Error de API");
                        const result = await response.json();
                        const audioData = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                        if (audioData) {
                            const binaryString = atob(audioData);
                            const len = binaryString.length;
                            const bytes = new Uint8Array(len);
                            for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
                            const pcm16 = new Int16Array(bytes.buffer);
                            const wavBlob = pcmToWav(pcm16, 24000); 
                            const newAudioUrl = URL.createObjectURL(wavBlob);
                            
                            onGeneration(newAudioUrl); 
                        }
                    } catch (e) {
                        setError("Error TTS");
                    } finally {
                        setIsLoading(false);
                    }
                };
                generateAndSetAudio();
            }, [text, audioUrl, onGeneration, needsTTS]);

            const togglePlay = () => {
                if (!audioRef.current) return;
                if (isPlaying) audioRef.current.pause();
                else audioRef.current.play().catch(e => setError("No se pudo reproducir"));
            };

            if (isLoading) return <div className="flex items-center gap-2 p-2 bg-gray-800 rounded-xl text-xs text-gray-400"><Loader2 size={16} className="animate-spin" /><span>Cargando...</span></div>;
            if (error) return <div className="flex items-center gap-2 p-2 bg-red-900/50 rounded-xl text-xs text-red-200 border border-red-700"><AlertTriangle size={16} /><a href={audioUrl} target="_blank" className="underline">Error</a></div>;
            if (!audioUrl && text && text.length <= 100) return <p className="whitespace-pre-wrap">{text}</p>;

            return (
                <div onClick={togglePlay} className={`flex items-center gap-3 p-2 rounded-xl cursor-pointer shadow-md w-fit max-w-full ${isMe ? 'bg-green-600' : 'bg-cyan-600'}`}>
                    <audio ref={audioRef} src={audioUrl} onPlay={() => setIsPlaying(true)} onPause={() => setIsPlaying(false)} onEnded={() => setIsPlaying(false)} preload="metadata"/>
                    <div className={`w-8 h-8 rounded-full flex items-center justify-center bg-white ${isMe ? 'text-green-600' : 'text-cyan-600'}`}>{isPlaying ? <Pause size={16} fill="currentColor" /> : <Play size={16} fill="currentColor" className="ml-0.5" />}</div>
                    <div className={`waveform ${isPlaying ? 'playing' : ''}`}>{bars}</div>
                    <span className="text-white text-xs whitespace-nowrap">{isPlaying ? 'Oyendo...' : 'Audio'}</span>
                </div>
            );
        };
        
        const ToastNotification = ({ notif, onClose }) => {
            useEffect(() => { const timer = setTimeout(onClose, 4000); return () => clearTimeout(timer); }, []);
            if (!notif) return null;
            return (
                <div className="fixed top-4 left-4 right-4 z-[100] animate-slide-down">
                    <div className="bg-gray-800/90 backdrop-blur-md border border-gray-700 p-3 rounded-2xl shadow-2xl flex items-center gap-3" onClick={onClose}>
                        <div className="w-10 h-10 rounded-full bg-gray-700 overflow-hidden flex-shrink-0 border border-gray-600"><img src={notif.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${notif.fromUser}`} className="w-full h-full object-cover" /></div>
                        <div className="flex-1 min-w-0"><p className="text-sm font-bold text-white truncate">{notif.fromName}</p><p className="text-xs text-gray-300 truncate">{notif.type === 'message' ? 'Te envió un mensaje' : notif.type === 'like' ? 'Le gustó tu video' : notif.type === 'follow' ? 'Comenzó a seguirte' : 'Nueva notificación'}</p></div>
                        <div className="w-2 h-2 bg-cyan-400 rounded-full"></div>
                    </div>
                </div>
            );
        };
        
        const StickerMessage = ({ stickerUrl }) => (<img src={stickerUrl} alt="Sticker" className="max-w-[150px] max-h-[150px] object-contain rounded-xl shadow-lg"/>);
        
        const GameInviteMessage = ({ data, isMe }) => {
            const game = GAMES_CONFIG.find(g => g.name === data.gameName) || { name: "Juego Desconocido", color: "bg-gray-500", logo: "" };
            return (
                <div className={`p-3 rounded-xl shadow-lg border ${game.color} ${isMe ? 'bg-opacity-80' : 'bg-opacity-90'}`}>
                    <div className="flex items-center gap-3 mb-2"><img src={game.logo} className="w-8 h-8 rounded-full bg-white p-1"/><p className="font-bold text-lg text-white">¡Invitación a {game.name}!</p></div>
                    <p className="text-sm text-gray-200 mb-3">{data.message || `Tu amigo te invita a unirte a una partida de ${game.name}.`}</p>
                    <button onClick={(e) => { e.stopPropagation(); window.open(data.inviteLink, '_blank'); }} className="w-full py-2 bg-white text-black font-bold rounded-lg transition hover:bg-gray-200">Unirse a la Partida</button>
                </div>
            );
        };

        const ChatVideoPreview = ({ video, isMe }) => {
            const [isPlaying, setIsPlaying] = useState(false);
            const videoRef = useRef(null);
            const togglePlay = () => {
                if (!videoRef.current) return;
                if (isPlaying) { videoRef.current.pause(); setIsPlaying(false); } 
                else { videoRef.current.play().then(() => setIsPlaying(true)).catch(() => { videoRef.current.muted = true; videoRef.current.play().then(() => setIsPlaying(true)); }); }
            };
            return (
                <div className="chat-video-container bg-black/50 shadow-xl" onClick={togglePlay}>
                    <video ref={videoRef} src={video.url + '#t=0.1'} className="w-full h-full object-cover transition-opacity duration-300" muted={!isPlaying} loop playsInline style={{ opacity: isPlaying ? 1 : 0.8 }}/>
                    {!isPlaying && (<div className="chat-video-play-icon"><Play size={30} className="text-white fill-white" /></div>)}
                    <div className="absolute inset-x-0 bottom-0 p-2 bg-gradient-to-t from-black/80 to-transparent"><p className="text-xs font-bold text-white truncate">{video.description || 'Video Compartido'}</p><p className="text-[10px] text-gray-300">@{video.authorName}</p></div>
                </div>
            );
        };
        
        const MessageBubble = ({ message, isMe, onDelete, onReply, videos, onUpdateAudioUrl }) => {
            const [showMenu, setShowMenu] = useState(false);
            const pressTimer = useRef(null);
            const video = message.type === 'video' ? videos.find(v => v.id === message.videoId) : null;
            
            const handleAudioUrlUpdate = async (newUrl) => {
                if (message.type === 'text' && !message.fileUrl) {
                    await updateDoc(doc(db, 'artifacts', appId, 'chats', message.chatId, 'messages', message.id), { fileUrl: newUrl, type: 'audio_tts' });
                }
            };

            const handleMouseDown = (e) => { if(e.button === 2) return; clearTimeout(pressTimer.current); pressTimer.current = setTimeout(() => { setShowMenu(true); setTimeout(() => setShowMenu(false), 5000); }, 500); };
            const handleMouseUp = () => clearTimeout(pressTimer.current);

            const isGif = message.type === 'image' && (message.fileUrl.toLowerCase().endsWith('.gif') || message.fileUrl.toLowerCase().includes('.gif'));
            const isAudioOrTTS = message.type === 'audio' || message.type === 'audio_tts' || (message.type === 'text' && message.text?.length > 100);

            if (message.type === 'sticker') return (<div className={`flex ${isMe ? 'justify-end' : 'justify-start'} group w-full`} onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} onTouchStart={handleMouseDown} onTouchEnd={handleMouseUp}><div className="relative">{isMe && (<button onClick={(e) => { e.stopPropagation(); onDelete(message.id); }} className={`absolute z-20 p-1 bg-red-600 rounded-full text-white top-1/2 -translate-y-1/2 right-full mr-3 ${showMenu ? 'opacity-100' : 'opacity-0'}`}><X size={16}/></button>)}<StickerMessage stickerUrl={message.fileUrl} /></div></div>);
            if (message.type === 'game_invite') return (<div className={`flex ${isMe ? 'justify-end' : 'justify-start'} group w-full`} onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} onTouchStart={handleMouseDown} onTouchEnd={handleMouseUp}><div className="relative max-w-[85%]">{isMe && (<button onClick={(e) => { e.stopPropagation(); onDelete(message.id); }} className={`absolute z-20 p-1 bg-red-600 rounded-full text-white top-1/2 -translate-y-1/2 right-full mr-3 ${showMenu ? 'opacity-100' : 'opacity-0'}`}><X size={16}/></button>)}<GameInviteMessage data={message.data} isMe={isMe} /></div></div>);
            if (message.type === 'gift') return (<div className={`flex ${isMe ? 'justify-end' : 'justify-start'} group w-full`}><div className={`relative max-w-[80%] p-3 rounded-2xl shadow-xl border border-pink-700 ${isMe ? 'bg-pink-900/50' : 'bg-pink-900/70'}`}><div className="flex items-center gap-2 mb-2"><Zap size={18} className="text-yellow-400 fill-yellow-400" /><span className="font-bold text-yellow-400 text-sm">{isMe ? 'Enviaste' : 'Recibiste'} un regalo!</span></div><img src={message.giftUrl} alt={message.giftName} className={`w-32 h-32 object-contain mx-auto my-2 rounded-lg ${message.giftAnimation || ''}`}/>{message.text && <p className="text-sm text-white whitespace-pre-wrap mt-2">{message.text}</p>}<div className="text-xs text-pink-300/80 mt-1 text-right">{message.giftPrice.toLocaleString()} BITS</div>{isMe && (<button onClick={(e) => { e.stopPropagation(); onDelete(message.id); }} className="absolute top-1 right-1 p-1 bg-red-600/50 rounded-full text-white"><X size={12}/></button>)}</div></div>);

            return (
                <div className={`flex ${isMe ? 'justify-end' : 'justify-start'} group w-full`} onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} onTouchStart={handleMouseDown} onTouchEnd={handleMouseUp}>
                    <div className={`relative max-w-[80%]`}>
                        <button onClick={(e) => { e.stopPropagation(); onReply(message); setShowMenu(false); }} className={`absolute z-20 p-1.5 bg-gray-800 rounded-full text-white top-1/2 -translate-y-1/2 ${isMe ? 'right-full mr-2' : 'left-full ml-2'} ${showMenu ? 'opacity-100' : 'opacity-0 scale-0'}`}>{ICONS.reply({ size: 14 })}</button>
                        {isMe && (<button onClick={(e) => { e.stopPropagation(); onDelete(message.id); setShowMenu(false); }} className={`absolute z-20 p-1 bg-red-600 rounded-full text-white -top-2 -left-2 ${showMenu ? 'opacity-100' : 'opacity-0 scale-0'}`}><X size={12}/></button>)}
                        <div className={`p-3 rounded-2xl text-sm relative ${isMe ? 'bg-white text-black' : 'bg-gray-800 text-white'} ${showMenu ? 'ring-2 ring-cyan-500/50' : ''}`}>
                            {message.replyTo && (<div className="p-2 mb-2 bg-white/10 border-l-4 border-cyan-400 rounded-md text-xs text-gray-500"><p className="font-bold text-cyan-600">Respuesta</p><p className="truncate italic">{message.replyTo.text || message.replyTo.type}</p></div>)}
                            {isAudioOrTTS || (message.type === 'text' && message.text?.length <= 100) ? (<AudioMessage audioUrl={message.fileUrl} isMe={isMe} text={message.text} onGeneration={handleAudioUrlUpdate}/>) : null}
                            {message.type === 'image' && (<div className="flex flex-col"><img src={message.fileUrl} className={`max-w-full rounded-lg mb-1 ${isGif ? 'max-h-60' : 'max-h-48'}`}/>{message.text && <p className="whitespace-pre-wrap">{message.text}</p>}</div>)}
                            {message.type === 'file' && (<div className="flex flex-col"><a href={message.fileUrl} target="_blank" className="flex items-center gap-2 text-cyan-600 font-bold mb-1"><FileText size={16} /> Archivo</a>{message.text && <p className="whitespace-pre-wrap">{message.text}</p>}</div>)}
                            {message.type === 'video' && (video ? <ChatVideoPreview video={video} isMe={isMe} /> : <div className="text-gray-400 text-xs">Video no encontrado.</div>)}
                        </div>
                    </div>
                </div>
            );
        };

        const GiftingModal = ({ isOpen, onClose, onSendGift, userBalance }) => {
            const [selectedGift, setSelectedGift] = useState(GIFTS_CONFIG[0]);
            const [message, setMessage] = useState('');
            const [animation, setAnimation] = useState('');
            if (!isOpen) return null;
            
            // --- FIX CRÍTICO: Si no hay balance, mostrar 0 y un aviso ---
            const currentBalance = (userBalance !== undefined && userBalance !== null) ? userBalance : 0;
            const isLoadingBalance = userBalance === undefined; 
            
            const handleSelectGift = (gift) => {
                setSelectedGift(gift);
                setMessage(''); 
            };

            const handleSend = () => {
                if (!selectedGift) return;
                onSendGift(selectedGift, message.trim(), animation);
                onClose();
            };

            return (
                <div className="fixed inset-0 z-50 bg-black/80 flex items-end">
                    <div className="bg-gray-900 w-full rounded-t-2xl p-6 border-t border-gray-700 animate-in slide-in-from-bottom">
                        <h3 className="text-white font-bold text-lg mb-4 flex justify-between items-center">
                            Enviar un Regalo <Zap size={20} className="text-yellow-400 fill-yellow-400"/>
                            <button onClick={onClose}><X size={20} className="text-gray-400"/></button>
                        </h3>
                        
                        {/* Carrete de Regalos */}
                        <div className="grid grid-cols-4 sm:grid-cols-6 gap-3 max-h-48 overflow-y-auto mb-6 p-2 bg-gray-800/50 rounded-xl">
                            {GIFTS_CONFIG.map(gift => {
                                const isDisabled = currentBalance < gift.price;
                                return (
                                    <div 
                                        key={gift.id} 
                                        className={`gift-card aspect-square rounded-xl flex flex-col items-center justify-center p-1 border-2 transition-all ${
                                            selectedGift.id === gift.id 
                                                ? 'border-cyan-400 bg-cyan-900/40 shadow-xl' 
                                                : 'border-gray-700 bg-gray-800/40 hover:bg-gray-700/60'
                                        } ${isDisabled ? 'disabled' : ''}`}
                                        onClick={() => !isDisabled && handleSelectGift(gift)}
                                        title={isDisabled ? `Faltan ${(gift.price - currentBalance).toLocaleString()} BITS` : gift.name}
                                    >
                                        <img src={gift.url} alt={gift.name} className="w-10 h-10 object-contain mb-1" />
                                        <div className="text-xs font-semibold text-white/90 truncate w-full text-center">{gift.price.toLocaleString()}</div>
                                        <div className="flex items-center gap-1 text-[10px] text-yellow-400">
                                            BITS <img src={BIT_COIN_LOGO_URL} className="w-2.5 h-2.5 rounded-full" />
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                        
                        {/* Vista Previa y Mensaje */}
                        <div className="flex flex-col md:flex-row gap-4 mb-4">
                            <div className="w-full md:w-1/3 bg-gray-800 rounded-xl p-4 text-center border border-cyan-400/20">
                                <p className="text-sm font-bold text-cyan-400 mb-2">Vista Previa</p>
                                <img src={selectedGift.url} alt={selectedGift.name} className={`w-20 h-20 object-contain mx-auto ${animation}`} />
                                <p className="text-sm font-bold mt-2">{selectedGift.name}</p>
                                <div className="text-lg font-extrabold text-yellow-400 mt-1">{selectedGift.price.toLocaleString()} BITS}</div>
                            </div>
                            
                            <div className="w-full md:w-2/3 space-y-3">
                                <textarea 
                                    value={message} 
                                    onChange={e => setMessage(e.target.value)} 
                                    placeholder="Añade un mensaje o dedicatoria (opcional)" 
                                    className="w-full bg-gray-800 text-white p-3 rounded-lg outline-none resize-none h-24 border border-gray-700" 
                                />
                                <input 
                                    type="text"
                                    value={animation}
                                    onChange={e => setAnimation(e.target.value)}
                                    placeholder="Clase CSS de animación (Ej: animate-spin)"
                                    className="w-full bg-gray-800 text-white p-3 rounded-lg border border-gray-700 outline-none" 
                                />
                            </div>
                        </div>

                        {/* Botón de Envío y Balance */}
                        <div className="flex justify-between items-center mt-3">
                            <p className="text-sm text-gray-400">
                                {/* FIX CRÍTICO: Mostrar balance actual o 0 si indefinido */}
                                {isLoadingBalance ? (
                                    <span className="text-yellow-500 animate-pulse">Cargando saldo...</span>
                                ) : (
                                    <>Tu Balance: <span className={currentBalance < selectedGift.price ? 'text-red-500 font-bold' : 'text-green-400 font-bold'}>{currentBalance.toLocaleString()} BITS</span></>
                                )}
                            </p>
                            <button 
                                onClick={handleSend} 
                                disabled={currentBalance < selectedGift.price || !selectedGift || isLoadingBalance} 
                                className="py-3 px-6 bg-cyan-600 text-white font-bold rounded-xl transition hover:bg-cyan-500 disabled:opacity-50 shadow-lg"
                            >
                                Enviar Regalo ({selectedGift.price.toLocaleString()} BITS)
                            </button>
                        </div>
                        
                        {!isLoadingBalance && currentBalance < selectedGift.price && (
                            <p className="text-red-500 text-sm mt-2">¡BITS insuficientes para este regalo!</p>
                        )}
                        <button onClick={onClose} className="w-full text-gray-400 text-sm mt-3">Cerrar</button>
                    </div>
                </div>
            );
        };

        const CommentsModal = ({ isOpen, onClose, video, user, userProfile }) => {
            const [comments, setComments] = useState([]);
            const [newComment, setNewComment] = useState('');
            const [showGiftModal, setShowGiftModal] = useState(false); // NUEVO
            const [error, setError] = useState('');
            const commentsEndRef = useRef(null);

            useEffect(() => {
                if (!isOpen || !video?.id) return;
                setError('');
                const q = query(collection(db, 'artifacts', appId, 'public', 'data', 'videos', video.id, 'comments'), orderBy('createdAt', 'asc'));
                const unsub = onSnapshot(q, s => {
                    setComments(s.docs.map(d => ({id: d.id, ...d.data()})).map(c => ({...c, isVerified: c.isVerified || false, avatar: c.avatar || `https://api.dicebear.com/7.x/avataaars/svg?seed=${c.authorId}`})));
                });
                return () => unsub();
            }, [isOpen, video?.id]);

            useEffect(() => { if (commentsEndRef.current) commentsEndRef.current.scrollIntoView({ behavior: 'smooth' }); }, [comments.length]);

            const getAuthorData = async () => {
                // IMPORTANTE: Buscamos por authUid en la colección 'users' raíz para tener los datos más frescos
                const q = query(collection(db, "users"), where("authUid", "==", user.uid), limit(1));
                const snap = await getDocs(q);
                if (!snap.empty) {
                     return snap.docs[0].data();
                }
                // Fallback a artifacts si no está en users
                const userDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', user.uid));
                return userDoc.data() || {};
            };

            const handleSendComment = async () => {
                if (!user?.uid || !newComment.trim()) return;
                setError('');
                const userData = await getAuthorData();

                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'videos', video.id, 'comments'), {
                    type: 'text',
                    authorId: user.uid, 
                    authorName: userData.username || userData.displayName || user.displayName || 'Usuario', 
                    authorUsername: userData.username || user.displayName,
                    avatar: userData.profilePicture || userData.photoURL || `https://api.dicebear.com/7.x/avataaars/svg?seed=${user.uid}`, 
                    text: newComment.trim(), 
                    createdAt: serverTimestamp(), 
                    isVerified: userData.isVerified || false 
                });
                setNewComment('');
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'videos', video.id), { commentsCount: increment(1) });
            };
            
            // --- FIX CRÍTICO: Envío de Regalos con Auto-reparación ---
            const handleSendGift = async (gift, message, animation) => {
                if (!user?.uid || !video?.authorId) return;
                if (!userProfile) {
                     setError('Perfil no cargado. Espera un momento.');
                     return;
                }
                
                setError('');

                if (userProfile.bitBalance < gift.price) {
                    setError('Saldo insuficiente para enviar este regalo.');
                    return;
                }
                
                try {
                    const userData = await getAuthorData();

                    // 1. Obtener la wallet del autor
                    const authorQuery = query(collection(db, "users"), where("authUid", "==", video.authorId), limit(1));
                    const authorSnap = await getDocs(authorQuery);
                    
                    let authorWallet;

                    if (!authorSnap.empty) {
                        authorWallet = authorSnap.docs[0].id;
                    } else {
                        // AUTO-REPARACIÓN: Si no existe en 'users', migrar desde 'artifacts'
                        const oldUserRef = doc(db, 'artifacts', appId, 'public', 'data', 'users', video.authorId);
                        const oldUserSnap = await getDoc(oldUserRef);
                        
                        if (oldUserSnap.exists()) {
                            const oldData = oldUserSnap.data();
                            authorWallet = oldData.walletAddress || video.authorId; 
                            
                            // Crear perfil en 'users' para que pueda recibir el pago
                            await setDoc(doc(db, 'users', authorWallet), {
                                walletAddress: authorWallet,
                                username: oldData.displayName || "Usuario",
                                profilePicture: oldData.photoURL,
                                bitBalance: oldData.bitBalance || 0,
                                authUid: video.authorId,
                                createdAt: serverTimestamp()
                            }, { merge: true });
                            
                        } else {
                            // Si tampoco existe en artifacts, creamos un placeholder
                             authorWallet = video.authorId; // Usamos el UID como wallet temporal
                             await setDoc(doc(db, 'users', authorWallet), {
                                walletAddress: authorWallet,
                                username: video.authorName || "Usuario",
                                authUid: video.authorId,
                                bitBalance: 0
                            }, { merge: true });
                        }
                    }
                    
                    // 2. Obtener wallet del remitente
                    const senderWallet = userProfile.id; 

                    if (!senderWallet) {
                        setError('Tu perfil no tiene wallet asociada.');
                        return;
                    }

                    // 3. Transacción
                    await runTransaction(db, async (t) => {
                        const senderRef = doc(db, 'users', senderWallet);
                        const authorRef = doc(db, 'users', authorWallet);
                        
                        const senderSnap = await t.get(senderRef);
                        if (!senderSnap.exists()) throw "Remitente no existe";
                        
                        const newSenderBalance = senderSnap.data().bitBalance - gift.price;
                        if (newSenderBalance < 0) throw "Saldo insuficiente";

                        t.update(senderRef, { bitBalance: increment(-gift.price) });
                        t.update(authorRef, { bitBalance: increment(gift.price) });
                    });
                    
                    // 4. Registrar comentario
                    await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'videos', video.id, 'comments'), {
                        type: 'gift', 
                        authorId: user.uid, 
                        authorName: userProfile.username || userProfile.displayName, 
                        authorUsername: userProfile.username,
                        avatar: userProfile.profilePicture || userProfile.photoURL, 
                        text: message, 
                        createdAt: serverTimestamp(), 
                        isVerified: userProfile.isVerified || false,
                        giftName: gift.name,
                        giftUrl: gift.url,
                        giftPrice: gift.price,
                        giftAnimation: animation
                    });
                    
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'videos', video.id), { commentsCount: increment(1) });
                    setShowGiftModal(false);
                    setError('');

                } catch (e) { 
                    console.error("Error envío regalo:", e); 
                    setError('Error al procesar el regalo: ' + (e.message || e)); 
                }
            };

            const handleDeleteComment = async (commentId) => {
                await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'videos', video.id, 'comments', commentId));
                 await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'videos', video.id), { commentsCount: increment(-1) });
            };
            
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 bg-black/80 flex items-end">
                    <div className="bg-gray-900 w-full rounded-t-2xl p-4 flex flex-col h-2/3 border-t border-gray-700 animate-in slide-in-from-bottom">
                        <div className="flex justify-between items-center border-b border-gray-800 pb-3 mb-3"><span className="text-white font-bold text-lg">Comentarios ({comments.length})</span><button onClick={onClose}><X size={20} className="text-gray-400"/></button></div>
                        <div className="flex-1 overflow-y-auto space-y-4 pr-2 no-scrollbar">
                            {comments.map((comment) => (
                                <div key={comment.id} className="flex gap-3 relative group">
                                    <div className="w-8 h-8 rounded-full overflow-hidden flex-shrink-0"><img src={comment.avatar} className="w-full h-full object-cover"/></div>
                                    <div className="flex-1 min-w-0">
                                        <div className="flex items-center gap-1"><p className="font-bold text-sm text-gray-300">@{comment.authorUsername}</p>{comment.isVerified && <VerifiedBadge size={12} />}</div>
                                        {comment.type === 'gift' ? (
                                            <div className="p-3 bg-pink-900/50 rounded-xl shadow-md mt-1 border border-pink-700"><div className="flex items-center gap-2 mb-1"><Zap size={16} className="text-yellow-400 fill-yellow-400" /><span className="font-bold text-yellow-400 text-sm">Regalo Enviado!</span></div><img src={comment.giftUrl} className={`w-20 h-20 object-contain my-1 rounded-lg ${comment.giftAnimation}`}/>{comment.text && <p className="text-sm text-white whitespace-pre-wrap mt-1">{comment.text}</p>}<div className="text-xs text-pink-300/80 mt-1 text-right">{comment.giftPrice.toLocaleString()} BITS</div></div>
                                        ) : (<p className="text-sm text-white">{comment.text}</p>)}
                                    </div>
                                    {(comment.authorId === user?.uid || video.authorId === user?.uid) && (<button onClick={() => handleDeleteComment(comment.id)} className="absolute right-0 top-1 text-red-400 opacity-0 group-hover:opacity-100"><X size={14}/></button>)}
                                </div>
                            ))}<div ref={commentsEndRef} />
                        </div>
                        <div className="mt-4 border-t border-gray-800 pt-4">
                            {error && <p className="text-red-500 text-sm mb-2 text-center bg-red-900/20 p-2 rounded-lg">{error}</p>}
                            <div className="flex gap-2 items-end">
                                <button onClick={() => setShowGiftModal(true)} className="w-10 h-10 p-2 bg-cyan-600 rounded-full flex items-center justify-center"><Zap size={20} className="fill-white"/></button>
                                <textarea value={newComment} onChange={(e) => setNewComment(e.target.value)} onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendComment(); } }} placeholder="Añadir comentario..." className="chat-input flex-1 bg-gray-800 text-white p-3 rounded-2xl outline-none resize-none max-h-20" rows={1}/>
                                <button onClick={handleSendComment} disabled={!newComment.trim()} className="w-10 h-10 p-2 bg-white rounded-full text-black flex items-center justify-center"><Send size={18}/></button>
                            </div>
                        </div>
                        <GiftingModal isOpen={showGiftModal} onClose={() => setShowGiftModal(false)} onSendGift={handleSendGift} userBalance={userProfile?.bitBalance}/>
                    </div>
                </div>
            );
        };

        const StickerModal = ({ isOpen, onClose, onSelectSticker }) => {
            if (!isOpen) return null;
            return (<div className="fixed inset-0 z-50 bg-black/80 flex items-end"><div className="bg-gray-900 w-full rounded-t-2xl p-6 border-t border-gray-700 animate-in slide-in-from-bottom"><h3 className="text-white font-bold text-lg mb-4 flex justify-between items-center">Enviar Sticker<button onClick={onClose}><X size={20} className="text-gray-400"/></button></h3><div className="grid grid-cols-3 sm:grid-cols-4 gap-4 max-h-64 overflow-y-auto">{STICKERS.map((url, index) => (<div key={index} className="aspect-square bg-gray-800 rounded-xl flex items-center justify-center cursor-pointer hover:bg-gray-700 transition" onClick={() => onSelectSticker(url)}><img src={url} alt={`Sticker ${index + 1}`} className="max-w-[80%] max-h-[80%] object-contain" /></div>))}</div></div></div>);
        };
        
        const GameInviteModal = ({ isOpen, onClose, onSendInvite }) => {
            if (!isOpen) return null;
             const [selectedGame, setSelectedGame] = useState(GAMES_CONFIG[0]); const [inviteLink, setInviteLink] = useState(''); const [message, setMessage] = useState('');
             const handleSend = () => { if (!inviteLink.trim()) return; onSendInvite(selectedGame.name, inviteLink.trim(), message.trim()); onClose(); };
             return (<div className="fixed inset-0 z-50 bg-black/80 flex items-center justify-center p-6"><div className="bg-gray-900 w-full max-w-sm rounded-xl p-6 border border-gray-700 shadow-2xl"><h3 className="text-white font-bold text-xl mb-4 flex items-center justify-between">Invitar a Jugar <Gamepad size={24} className="text-cyan-400"/></h3><div className="mb-4"><label className="block text-sm font-medium text-gray-400 mb-2">Selecciona un Juego</label><div className="flex flex-wrap gap-2">{GAMES_CONFIG.map(game => (<button key={game.name} onClick={() => setSelectedGame(game)} className={`flex items-center gap-2 p-2 rounded-full border transition-all ${selectedGame.name === game.name ? 'bg-cyan-600 border-cyan-400 text-white shadow-md' : 'bg-gray-800 border-gray-700 text-gray-300 hover:bg-gray-700'}`}><img src={game.logo} alt={game.name} className="w-5 h-5 rounded-full"/><span className="text-sm">{game.name}</span></button>))}</div></div><input type="text" value={inviteLink} onChange={(e) => setInviteLink(e.target.value)} placeholder={selectedGame.placeholder} className="w-full bg-gray-800 text-white p-3 rounded-lg border border-gray-700 outline-none mb-4"/><textarea value={message} onChange={e => setMessage(e.target.value)} placeholder="¡Vamos a ganar!" className="w-full bg-gray-800 text-white p-3 rounded-lg mb-4 outline-none resize-none h-20"/><button onClick={handleSend} disabled={!inviteLink.trim()} className="w-full py-3.5 bg-white text-black font-bold rounded-xl disabled:opacity-50 hover:bg-gray-200 transition shadow-lg">Enviar Invitación</button><button onClick={onClose} className="w-full text-gray-400 text-sm mt-3">Cerrar</button></div></div>);
        };
        
        const ShareVideoModal = ({ isOpen, onClose, videoId, user, chats }) => {
            if (!isOpen) return null;
            const [selectedChat, setSelectedChat] = useState(null);
            const handleSend = async () => {
                if (!user?.uid || !selectedChat || !videoId) return; 
                await addDoc(collection(db, 'artifacts', appId, 'chats', selectedChat, 'messages'), { type: 'video', videoId: videoId, senderId: user.uid, createdAt: new Date().toISOString() });
                onClose();
            };
            return (<div className="fixed inset-0 z-50 bg-black/80 flex items-end"><div className="bg-gray-900 w-full rounded-t-2xl p-6 border-t border-gray-700 animate-in slide-in-from-bottom"><h3 className="text-white font-bold text-lg mb-4 flex justify-between items-center">Compartir en Chat<button onClick={onClose}><X size={20} className="text-gray-400"/></button></h3><div className="max-h-64 overflow-y-auto space-y-3 mb-6">{chats.filter(c => c.status === 'accepted').map(chat => { const otherUid = chat.participants.find(uid => uid !== user.uid); const otherUser = chat.participantsData?.[otherUid]; return (<div key={chat.id} onClick={() => setSelectedChat(chat.id)} className={`flex items-center gap-3 p-3 rounded-xl border cursor-pointer transition ${selectedChat === chat.id ? 'bg-cyan-600 border-cyan-400' : 'bg-gray-800/40 border-gray-700'}`}><div className="w-10 h-10 rounded-full overflow-hidden flex-shrink-0"><img src={otherUser?.photoURL || `https://api.dicebear.com/7.x/avataaars/svg?seed=${otherUid}`} className="w-full h-full object-cover"/></div><span className="font-medium text-white">{otherUser?.displayName}</span></div>); })}</div><button onClick={handleSend} disabled={!selectedChat} className="w-full py-3.5 bg-white text-black font-bold rounded-xl disabled:opacity-50">Enviar Video</button></div></div>);
        };

        const AuthScreen = () => {
             const [isRegistering, setIsRegistering] = useState(false); const [walletAddress, setWalletAddress] = useState(""); const [password, setPassword] = useState(""); const [error, setError] = useState(""); const [loading, setLoading] = useState(false);
            
            const handleAuth = async (e) => {
                e.preventDefault(); setError(""); setLoading(true); 
                if (walletAddress.length < 32 || walletAddress.length > 44) { setError('Wallet inválida.'); setLoading(false); return; }
                if (password.length < 6) { setError('Contraseña mín. 6 caracteres.'); setLoading(false); return; }
                const fakeEmail = `${walletAddress}@livepayout.app`;
                
                try {
                    let userCredential;
                    if (isRegistering) { 
                        userCredential = await createUserWithEmailAndPassword(auth, fakeEmail, password); 
                        const user = userCredential.user;
                        const defaultDisplayName = `Wallet...${walletAddress.substring(walletAddress.length - 4)}`; 
                        
                        // CRÍTICO: Crear perfil en colección raíz 'users' usando walletAddress como ID
                        await setDoc(doc(db, 'users', walletAddress), { 
                            walletAddress: walletAddress,
                            username: defaultDisplayName, // Nombre visible
                            profilePicture: `https://api.dicebear.com/7.x/avataaars/svg?seed=${user.uid}`, 
                            bitBalance: 1000,
                            authUid: user.uid,
                            followersCount: 0,
                            followingCount: 0,
                            creatorRewardsBalance: 0,
                            createdAt: serverTimestamp(),
                            bio: "Nuevo en LiveClips"
                        });
                        // También creamos referencia en artifacts para compatibilidad interna de TikTokYout si es necesaria, pero la principal es users
                        await updateProfile(user, { displayName: defaultDisplayName });
                    } else { 
                        userCredential = await signInWithEmailAndPassword(auth, fakeEmail, password); 
                        // Verificar si existe en users
                        const userDoc = await getDoc(doc(db, 'users', walletAddress));
                        if (!userDoc.exists()) {
                             // Si loguea pero no existe (caso raro de migración), crearlo
                             await setDoc(doc(db, 'users', walletAddress), {
                                walletAddress: walletAddress, username: `User ${walletAddress.slice(0,4)}`,
                                profilePicture: `https://api.dicebear.com/7.x/avataaars/svg?seed=${userCredential.user.uid}`,
                                bitBalance: 1000, authUid: userCredential.user.uid,
                                followersCount: 0, followingCount: 0, creatorRewardsBalance: 0
                             });
                        }
                    }
                    localStorage.setItem('walletAddress', walletAddress);
                } catch (err) { setError(err.message); } setLoading(false);
            };

            return (
                <div className="flex flex-col items-center justify-center h-screen bg-gray-950 text-white p-6 relative overflow-hidden">
                    <div className="absolute inset-0 bg-gradient-to-br from-gray-900 via-black to-gray-900 z-0"></div>
                    <div className="z-10 w-full max-w-sm bg-gray-900/80 backdrop-blur-xl border border-gray-700 p-8 rounded-3xl shadow-2xl">
                        <div className="flex flex-col items-center mb-8"><h1 className="text-3xl font-bold text-white mb-2">LiveClips</h1><p className="text-gray-400 text-sm">Sincronizado con Live Payout</p></div>
                        <form onSubmit={handleAuth} className="space-y-4"><input type="text" placeholder="Wallet Solana (Ej: 5x...yZ)" className="w-full bg-gray-800 text-white p-4 rounded-xl border border-gray-600 outline-none focus:border-cyan-400 transition" value={walletAddress} onChange={(e) => setWalletAddress(e.target.value)} /><input type="password" placeholder="Contraseña" className="w-full bg-gray-800 text-white p-4 rounded-xl border border-gray-600 outline-none focus:border-cyan-400 transition" value={password} onChange={(e) => setPassword(e.target.value)} />{error && <p className="text-red-400 text-xs">{error}</p>}<button type="submit" disabled={loading || !walletAddress || !password} className="w-full bg-white hover:bg-gray-200 text-black font-bold py-4 rounded-xl transition flex justify-center disabled:opacity-50">{loading ? <Loader2 className="animate-spin" /> : (isRegistering ? "Registrarse con Wallet" : "Entrar con Wallet")}</button></form><p className="mt-6 text-center text-sm text-gray-400 cursor-pointer hover:text-white transition" onClick={() => { setIsRegistering(!isRegistering); setError(""); }}>{isRegistering ? "¿Ya tienes cuenta? Inicia Sesión" : "Crear cuenta nueva"}</p>
                    </div>
                </div>
            );
        };

        const VideoPlayer = ({ video, isActive, toggleLike, onShare, onVisitProfile, onOpenComments, userProfile }) => {
             const videoRef = useRef(null); const [playing, setPlaying] = useState(false); const [progress, setProgress] = useState(0); const [buffering, setBuffering] = useState(false); const [hasLiked, setHasLiked] = useState(false); 
             // Usamos unificado para autor
             const authorProfile = useUnifiedProfile(video.authorId);

            useEffect(() => { if(!auth.currentUser || !video.id) return; const likeRef = doc(db, 'artifacts', appId, 'public', 'data', 'videos', video.id, 'likes', auth.currentUser.uid); const unsubscribe = onSnapshot(likeRef, (s) => { setHasLiked(s.exists()); }); return () => unsubscribe(); }, [video.id, auth.currentUser]);
            useEffect(() => { const videoEl = videoRef.current; if (!videoEl) return; if (isActive) { const playPromise = videoEl.play(); if (playPromise !== undefined) { playPromise.then(() => { setPlaying(true); videoEl.muted = false; }).catch(() => { videoEl.muted = true; videoEl.play().then(() => setPlaying(true)).catch(() => setPlaying(false)); }); } } else { videoEl.pause(); videoEl.currentTime = 0; setPlaying(false); } }, [isActive]);
            useEffect(() => { const el = videoRef.current; if(!el) return; const wait = () => setBuffering(true); const play = () => setBuffering(false); el.addEventListener('waiting', wait); el.addEventListener('playing', play); return () => { el.removeEventListener('waiting', wait); el.removeEventListener('playing', play); }; }, []);
            const togglePlay = () => { const el = videoRef.current; if(!el) return; if(el.paused) { el.play(); setPlaying(true); } else { el.pause(); setPlaying(false); } };
            const handleTime = () => { if(videoRef.current) setProgress((videoRef.current.currentTime / videoRef.current.duration) * 100); };
            
            // --- FIX CRÍTICO: Likes ---
            const handleLikeClick = async () => { 
                if(!auth.currentUser) return; 
                // Evitamos llamar a toggleLike si ya tiene like para no duplicar llamadas innecesarias
                if(!hasLiked) { 
                    try {
                        toggleLike(video, auth.currentUser.uid);
                        // Optimistic update
                        setHasLiked(true); 
                    } catch(e) {
                        console.error("Error al dar like:", e);
                    }
                } 
            };
            
            const renderDescriptionWithMentions = (text) => { const mentionRegex = /@(\w+)/g; let parts = []; let lastIndex = 0; let match; while ((match = mentionRegex.exec(text)) !== null) { const before = text.substring(lastIndex, match.index); const mention = match[0]; const username = match[1]; if (before) { parts.push(<React.Fragment key={`text-${lastIndex}`}>{before}</React.Fragment>); } parts.push(<span key={`mention-${match.index}`} className="text-cyan-400 font-semibold cursor-pointer pointer-events-auto hover:underline" onClick={(e) => { e.stopPropagation(); onVisitProfile(username); }}>{mention}</span>); lastIndex = match.index + mention.length; } if (lastIndex < text.length) { parts.push(<React.Fragment key={`text-${lastIndex}`}>{text.substring(lastIndex)}</React.Fragment>); } return <p className="text-sm drop-shadow-md line-clamp-2 mb-4 text-gray-200 font-light leading-relaxed">{parts}</p>; };
            const actionBtnClass = "p-2 bg-gray-800/80 rounded-xl border border-gray-600 backdrop-blur-md transition-all active:scale-90 hover:bg-gray-700 hover:border-gray-400 shadow-lg";
            return (<div className="relative w-full h-full snap-start bg-gray-900 overflow-hidden" style={{ height: '100dvh' }}><video ref={videoRef} src={video.url} className="w-full h-full object-cover opacity-90" loop playsInline onClick={togglePlay} onTimeUpdate={handleTime}/>{buffering && <div className="absolute inset-0 flex items-center justify-center z-20 pointer-events-none"><Loader2 size={50} className="text-white/50 animate-spin"/></div>}{!playing && !buffering && (<div className="absolute inset-0 flex items-center justify-center z-20 pointer-events-none"><div className="bg-white/10 backdrop-blur-md p-6 rounded-full border border-white/20 shadow-xl"><Play size={40} className="text-white fill-white opacity-80" /></div></div>)}<div className="absolute bottom-0 left-0 right-0 h-1 bg-gray-800/50 z-30"><div className="h-full bg-white transition-all duration-100 ease-linear shadow-[0_0_10px_rgba(255,255,255,0.5)]" style={{ width: `${progress}%` }} /></div><div className="absolute right-2 bottom-28 flex flex-col items-center gap-5 z-30">
                
                {userProfile && (
                     <div className="flex flex-col items-center gap-1"><div className="w-12 h-12 rounded-full bg-cyan-600/20 border border-cyan-400/50 flex items-center justify-center shadow-lg backdrop-blur-sm"><img src={BIT_COIN_LOGO_URL} className="w-6 h-6 object-cover rounded-full" /></div><span className="text-white text-xs font-bold drop-shadow-md">{userProfile.bitBalance?.toLocaleString() || '0'} <br/><span className='text-[10px] text-cyan-400'>BIT</span></span></div>
                )}
                
                <div onClick={() => onVisitProfile(video.authorId)} className="relative cursor-pointer transition-transform active:scale-90 mb-2"><div className="w-12 h-12 rounded-full border-2 border-white p-0.5 overflow-hidden bg-gray-800 shadow-lg"><img src={authorProfile?.profilePicture || `https://api.dicebear.com/7.x/avataaars/svg?seed=${video.authorId}`} className="w-full h-full object-cover" /></div><div className="absolute -bottom-2 left-1/2 -translate-x-1/2 bg-pink-500 rounded-full w-5 h-5 flex items-center justify-center shadow-md ring-2 ring-gray-900"><span className="text-white text-[10px] font-bold">+</span></div></div><button onClick={handleLikeClick} disabled={hasLiked} className="flex flex-col items-center gap-1 group disabled:opacity-70"><div className={actionBtnClass}><img src={ICONS.corazon} className={`w-7 h-7 transition-all duration-300 drop-shadow-lg ${hasLiked ? 'filter-red' : 'invert opacity-90'}`} /></div><span className="text-white text-xs font-medium drop-shadow-md">{video.likes}</span></button><button onClick={() => onOpenComments(video)} className="flex flex-col items-center gap-1 group"><div className={`${actionBtnClass} comments-btn-bg`}><MessageSquare className="w-7 h-7 text-white opacity-90 drop-shadow-lg"/></div><span className="text-white text-xs font-medium drop-shadow-md">{video.commentsCount || 0}</span></button><button onClick={() => onShare(video.id)} className="flex flex-col items-center gap-1 group"><div className={actionBtnClass}><img src={ICONS.compartir} className="w-7 h-7 invert opacity-90 drop-shadow-lg" /></div><span className="text-white text-xs font-medium drop-shadow-md">Share</span></button><div className={`mt-2 w-12 h-12 rounded-full bg-gray-800 border-[3px] border-gray-700 flex items-center justify-center overflow-hidden ${playing ? 'animate-spin-slow' : ''} shadow-lg`}><div className="w-full h-full bg-gradient-to-br from-gray-700 to-black flex items-center justify-center"><Music2 size={14} className="text-white drop-shadow-md" /></div></div></div><div className="absolute bottom-24 left-4 right-20 z-20 text-white pointer-events-none"><div className="flex items-center gap-1"><h3 className="font-bold text-lg drop-shadow-lg mb-2 text-gray-100 cursor-pointer pointer-events-auto w-fit" onClick={() => onVisitProfile(video.authorId)}>@{authorProfile?.username || video.authorName}</h3>{authorProfile?.isVerified && <VerifiedBadge size={18} />}</div>{renderDescriptionWithMentions(video.description)}<div className="flex items-center gap-2 text-xs font-medium bg-white/5 border border-white/10 w-fit px-4 py-2 rounded-full backdrop-blur-md shadow-sm"><Music2 size={12} /><span className="animate-marquee whitespace-nowrap max-w-[150px] overflow-hidden text-ellipsis">Sonido original - {video.authorName}</span></div></div></div>);
        };

        const ProfileView = ({ targetUserId, currentUser, videos, onBack, onVideoClick, onLogout, onChat }) => {
            // Perfil unificado
            const profile = useUnifiedProfile(targetUserId);
            const [isFollowing, setIsFollowing] = useState(false); const [isEditing, setIsEditing] = useState(false);
            const isMyProfile = targetUserId === currentUser?.uid; 
            const userVideos = videos.filter(v => v.authorId === targetUserId);
            
            useEffect(() => { 
                if (!profile) return;
                // Si es mi perfil, check follow logic is different or not needed for self
                if (!isMyProfile && currentUser) { 
                    // Verificar si el usuario actual sigue a la wallet del target
                    // Necesitamos la wallet del current user para buscar en 'users/{currentWallet}/following/{targetWallet}'
                    const currentWallet = localStorage.getItem('walletAddress');
                    if(currentWallet && profile.walletAddress) {
                        const checkFollow = onSnapshot(doc(db, 'users', currentWallet, 'following', profile.walletAddress), (s) => { setIsFollowing(s.exists()); }); 
                        return () => checkFollow();
                    }
                } 
            }, [profile, currentUser, isMyProfile]);

            const handleFollow = async () => { 
                if (!currentUser?.uid || !profile) return; 
                const currentWallet = localStorage.getItem('walletAddress');
                const targetWallet = profile.walletAddress;
                
                const myRef = doc(db, 'users', currentWallet, 'following', targetWallet); 
                const targetRef = doc(db, 'users', targetWallet, 'followers', currentWallet);
                const targetUserRef = doc(db, 'users', targetWallet);
                const myUserRef = doc(db, 'users', currentWallet);

                if (isFollowing) { 
                    await deleteDoc(myRef); 
                    await deleteDoc(targetRef);
                    await updateDoc(targetUserRef, { followersCount: increment(-1) }); 
                    await updateDoc(myUserRef, { followingCount: increment(-1) }); 
                } else { 
                    await setDoc(myRef, { since: new Date().toISOString() }); 
                    await setDoc(targetRef, { since: new Date().toISOString() }); 
                    await updateDoc(targetUserRef, { followersCount: increment(1) }); 
                    await updateDoc(myUserRef, { followingCount: increment(1) }); 
                    // Notificación en artifacts (híbrido)
                    const uData = (await getDoc(doc(db, 'users', currentWallet))).data();
                    await addDoc(collection(db, 'artifacts', appId, 'users', targetUserId, 'notifications'), { type: 'follow', fromUser: currentUser.uid, fromName: uData.username, avatar: uData.profilePicture, createdAt: new Date().toISOString() }); 
                } 
            };

            return (<div className="w-full h-full bg-gray-900 overflow-y-auto pb-24 animate-in slide-in-from-right"><div className="relative w-full h-40 bg-gray-950 border-b border-gray-800 shadow-md" style={{backgroundImage: `url(${profile?.bannerURL})`, backgroundSize: 'cover', backgroundPosition: 'center'}}><div className="absolute inset-0 bg-black/30"></div><div className="absolute top-0 left-0 w-full p-4 pt-8 flex items-center gap-4 z-10"><button onClick={onBack} className="p-2 bg-gray-800/50 rounded-full hover:bg-gray-700/70 transition"><ArrowLeft className="text-white"/></button></div></div><div className="flex flex-col items-center justify-center mb-6 px-4 -mt-16 relative z-10"><div className="w-24 h-24 rounded-full border-4 border-gray-900 p-1 mb-3 bg-gray-900 shadow-xl"><img src={profile?.profilePicture || `https://api.dicebear.com/7.x/avataaars/svg?seed=${targetUserId}`} className="w-full h-full rounded-full bg-gray-800 object-cover" /></div><div className="flex items-center gap-1"><h2 className="text-lg font-bold text-white">@{profile?.username || "Usuario"}</h2>{profile?.isVerified && <VerifiedBadge size={18} />}</div><p className="text-sm text-gray-400 text-center mt-1">{profile?.bio || "Sin biografía"}</p><div className="flex items-center gap-8 mt-6 text-center"><div><div className="font-bold text-white text-lg">{profile?.followingCount || 0}</div><div className="text-xs text-gray-500 uppercase font-bold">Siguiendo</div></div><div><div className="font-bold text-white text-lg">{profile?.followersCount || 0}</div><div className="text-xs text-gray-500 uppercase font-bold">Seguidores</div></div><div><div className="font-bold text-white text-lg">{profile?.bitBalance || 0}</div><div className="text-xs text-gray-500 uppercase font-bold">BITS</div></div></div><div className="flex gap-2 mt-6 w-full max-w-xs px-4">{currentUser && (isMyProfile ? (<><button onClick={() => setIsEditing(true)} className="flex-1 py-2 bg-gray-800 text-white text-sm font-bold rounded-lg border border-gray-600">Editar Perfil</button><button onClick={onLogout} className="w-10 flex items-center justify-center bg-gray-800 text-white rounded-lg border border-gray-600"><LogOut size={16}/></button></>) : (<><button onClick={handleFollow} className={`flex-1 py-2 text-white text-sm font-bold rounded-lg border transition-all flex items-center justify-center gap-2 ${isFollowing ? 'bg-gray-800 border-gray-600' : 'bg-white text-black hover:bg-gray-200'}`}>{isFollowing ? <><UserCheck size={16}/> Siguiendo</> : <><UserPlus size={16}/> Seguir</>}</button><button onClick={() => onChat(targetUserId, profile)} className="w-12 flex items-center justify-center bg-gray-800 text-white rounded-lg border border-gray-600"><MessageCircle size={18}/></button></>))}</div></div><div className="border-t border-gray-800 w-full bg-gray-900 min-h-[300px]"><div className="grid grid-cols-3 gap-0.5">{userVideos.map((video, idx) => (<div key={video.id} onClick={() => onVideoClick(video.id)} className="relative aspect-[3/4] bg-gray-800 cursor-pointer overflow-hidden"><video src={video.url + '#t=0.1'} className="w-full h-full object-cover opacity-90 hover:opacity-100 transition" preload="metadata" /><div className="absolute bottom-1 left-1 flex items-center gap-1 text-[10px] text-white font-bold drop-shadow-md"><Play size={10} fill="white"/> {video.likes || 0}</div></div>))}</div></div>{isMyProfile && <EditProfileModal isOpen={isEditing} onClose={() => setIsEditing(false)} user={currentUser} profile={profile} onUpdate={()=>{}} />}</div>);
        };

        const EditProfileModal = ({ isOpen, onClose, user, profile }) => {
             const [username, setUsername] = useState(profile?.username || "");
             const [bio, setBio] = useState(profile?.bio || ""); 
             const [loading, setLoading] = useState(false); 
             const photoInputRef = useRef(null); const bannerInputRef = useRef(null);
            
            useEffect(() => { if(profile) { setUsername(profile.username||""); setBio(profile.bio||""); } }, [profile]);
            
            const handleImageUpload = async (event, type) => {
                if (!user?.uid || !profile?.walletAddress) return; const file = event.target.files[0]; if (!file) return; setLoading(true);
                try { const path = `${type}s/${user.uid}_${Date.now()}_${file.name.replace(/[^a-zA-Z0-9.]/g,'')}`; const url = await uploadToGitHub(file, path, (s) => console.log(s)); 
                    const updateData = type === 'photo' ? { profilePicture: url } : { bannerURL: url }; 
                    await updateDoc(doc(db, 'users', profile.walletAddress), updateData);
                } catch(e) { console.error("Error al subir imagen:", e.message); } setLoading(false);
            };
            
            const handleSaveText = async () => { 
                if (!user?.uid || !profile?.walletAddress) return; 
                if (username.length < 2) return;
                setLoading(true); 
                await updateDoc(doc(db, 'users', profile.walletAddress), { username: username, bio: bio });
                setLoading(false); onClose(); 
            };
            
            if (!isOpen) return null;
            return (<div className="fixed inset-0 z-50 bg-black/80 flex items-center justify-center p-6"><div className="bg-gray-900 w-full max-w-xs rounded-xl p-6 border border-gray-700"><h3 className="text-white font-bold mb-4">Editar Perfil</h3>{loading && <div className="text-cyan-400 mb-4 flex items-center gap-2"><Loader2 className="animate-spin" size={16}/> Cargando...</div>}<div className="flex flex-col items-center mb-4"><label className="relative cursor-pointer mb-2"><div className="w-16 h-16 rounded-full border-2 border-white overflow-hidden bg-gray-800"><img src={profile?.profilePicture} className="w-full h-full object-cover"/></div><div className="absolute bottom-0 right-0 bg-cyan-600 rounded-full p-1.5 border border-gray-900"><Camera size={14} className="text-white"/></div><input type="file" accept="image/*" className="hidden" ref={photoInputRef} onChange={(e) => handleImageUpload(e, 'photo')} /></label><button onClick={() => photoInputRef.current.click()} className="text-xs text-gray-400 hover:text-white">Cambiar Foto</button></div><div className="w-full mb-4"><label className="relative cursor-pointer w-full h-16 block bg-gray-800 border border-gray-600 rounded-lg overflow-hidden"><img src={profile?.bannerURL} className="w-full h-full object-cover"/><div className="absolute inset-0 flex items-center justify-center bg-black/40 hover:bg-black/60 transition"><Camera size={18} className="text-white"/></div><input type="file" accept="image/*" className="hidden" ref={bannerInputRef} onChange={(e) => handleImageUpload(e, 'banner')} /></label><button onClick={() => bannerInputRef.current.click()} className="text-xs text-gray-400 hover:text-white mt-1 block">Cambiar Banner</button></div>
            <input value={username} onChange={e => setUsername(e.target.value)} className="w-full bg-gray-800 text-white p-3 rounded-lg mb-3 outline-none" placeholder="Nombre Visible" />
            <textarea value={bio} onChange={e => setBio(e.target.value)} className="w-full bg-gray-800 text-white p-3 rounded-lg mb-4 outline-none" placeholder="Bio" rows={3} /><button onClick={handleSaveText} disabled={loading} className="w-full bg-white text-black font-bold py-3 rounded-lg">{loading ? "Guardando..." : "Guardar Texto"}</button><button onClick={onClose} className="w-full text-gray-400 text-sm mt-3">Cerrar</button></div></div>);
        };

        const UploadModal = ({ isOpen, onClose, user, userProfile }) => {
            if (!isOpen) return null;
             const [file, setFile] = useState(null); const [preview, setPreview] = useState(null); const [desc, setDesc] = useState(""); const [loading, setLoading] = useState(false); const [status, setStatus] = useState("");
            const handleFile = (e) => { const f = e.target.files[0]; if(f) { setFile(f); setPreview(URL.createObjectURL(f)); }};
            const handleUpload = async () => { if(!user?.uid || !file) return; setLoading(true); try { const path = `videos/${Date.now()}_${file.name.replace(/[^a-zA-Z0-9.]/g,'')}`; const url = await uploadToGitHub(file, path, (s) => console.log(s)); 
            // Guardamos el video con los datos del perfil unificado
            await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'videos'), { url, authorId: user.uid, authorName: userProfile?.username || 'Usuario', authorAvatar: userProfile?.profilePicture, description: desc, likes: 0, commentsCount: 0, createdAt: new Date().toISOString() }); onClose(); setFile(null); setPreview(null); setDesc(""); } catch(e) { setStatus("Error: " + e.message); } setLoading(false); };
            return (<div className="fixed inset-0 z-50 bg-gray-900/95 backdrop-blur-xl flex flex-col animate-in fade-in"><div className="p-4 flex justify-between items-center border-b border-gray-700"><button onClick={onClose}><X className="text-gray-400 hover:text-white"/></button><h3 className="text-white font-bold flex items-center gap-2"><img src={ICONS.crear} className="w-6 h-6 invert"/> Nuevo Video</h3><div className="w-6"></div></div><div className="flex-1 p-6 flex flex-col items-center justify-center">{!preview ? (<label className="w-full h-64 border-2 border-dashed border-gray-600 rounded-2xl flex flex-col items-center justify-center cursor-pointer hover:border-gray-400 bg-gray-800/30"><div className="p-4 rounded-full bg-gray-700 mb-3"><img src={ICONS.crear} className="w-6 h-6 invert opacity-70"/></div><span className="text-gray-400 font-medium">Seleccionar video</span><input type="file" accept="video/*" className="hidden" onChange={handleFile}/></label>) : (<div className="relative w-full h-64 bg-black rounded-2xl overflow-hidden border border-gray-700"><video src={preview} className="w-full h-full object-contain"/><button onClick={()=>{setPreview(null);setFile(null)}} className="absolute top-2 right-2 bg-black/50 p-1.5 rounded-full text-white hover:bg-black/80"><X size={16}/></button></div>)}<textarea value={desc} onChange={e=>setDesc(e.target.value)} placeholder="Añade una descripción..." className="w-full bg-gray-900 text-white p-4 rounded-xl mt-6 h-24 outline-none resize-none border border-gray-700 focus:border-gray-500"/>{status && <p className="text-cyan-400 text-sm mt-2 animate-pulse">{status}</p>}<button disabled={loading||!file} onClick={handleUpload} className="w-full bg-white text-black font-bold py-3.5 rounded-xl mt-auto mb-4 disabled:opacity-50 hover:bg-gray-200 transition shadow-lg">{loading?"Publicando...":"Publicar Video"}</button></div></div>);
        };

        const TrendsView = ({ videos, onVideoClick, onVisitProfile }) => {
            const [search, setSearch] = useState(""); const [tab, setTab] = useState('videos'); const [users, setUsers] = useState([]);
            useEffect(() => { if (tab === 'users' && search.length >= 2) { 
                // Consulta a la colección compartida 'users'
                const q = query(collection(db, 'users'), where('username', '>=', search), where('username', '<=', search + '\uf8ff'), limit(10)); 
                const unsub = onSnapshot(q, (snap) => { setUsers(snap.docs.map(d => ({id: d.data().authUid, ...d.data()}))); }); return () => unsub(); 
            } else if (tab === 'users') { setUsers([]); } }, [tab, search]);
            const filteredVideos = videos.filter(v => (v.description || "").toLowerCase().includes(search.toLowerCase()) || (v.authorName || "").toLowerCase().includes(search.toLowerCase()));
            
            return (<div className="w-full h-full bg-gray-900 pt-4 px-4 overflow-y-auto pb-24 flex flex-col"> 
                <div className="relative mb-6"><input type="text" placeholder="Buscar..." value={search} onChange={(e) => setSearch(e.target.value)} className="w-full bg-gray-800 text-white p-3 pl-10 rounded-xl border border-gray-700 outline-none" /><Search className="absolute left-3 top-3.5 text-gray-500" size={18} /></div>
                <div className="flex gap-4 mb-6 border-b border-gray-800 pb-2"><button onClick={() => setTab('videos')} className={`text-sm font-bold pb-2 ${tab==='videos'?'text-white border-b-2 border-white':'text-gray-500'}`}>Videos</button><button onClick={() => setTab('users')} className={`text-sm font-bold pb-2 ${tab==='users'?'text-white border-b-2 border-white':'text-gray-500'}`}>Usuarios</button></div>
                {tab === 'videos' && (<><h3 className="font-bold text-white mb-4 flex items-center gap-2"><Hash className="text-cyan-400" size={18} /> Resultados de Videos</h3><div className="grid grid-cols-2 gap-2">{filteredVideos.map(video => (<div key={video.id} onClick={() => onVideoClick(video)} className="relative aspect-[9/16] bg-gray-800 rounded-xl overflow-hidden cursor-pointer group shadow-lg border border-gray-800"><video src={video.url + '#t=0.1'} className="w-full h-full object-cover opacity-80" muted preload="metadata" /><div className="absolute bottom-0 inset-x-0 p-2 bg-gradient-to-t from-black/80 to-transparent"><p className="text-xs font-bold text-white truncate">@{video.authorName}</p></div></div>))}</div></>)}
                {tab === 'users' && (<><h3 className="font-bold text-white mb-4 flex items-center gap-2"><UserIcon className="text-cyan-400" size={18} /> Usuarios Encontrados</h3><div className="space-y-2">{users.length === 0 && search.length >= 2 ? <p className="text-gray-500 text-center">No se encontraron usuarios.</p> : users.map(u => (<div key={u.authUid} onClick={() => onVisitProfile(u.authUid)} className="flex items-center gap-3 p-3 bg-gray-800/40 rounded-xl border border-gray-800 cursor-pointer hover:bg-gray-800"><div className="w-10 h-10 rounded-full bg-gray-700 overflow-hidden flex-shrink-0"><img src={u.profilePicture} className="w-full h-full object-cover"/></div><div className="flex-1"><div className="flex items-center gap-1"><p className="font-bold text-white">@{u.username}</p></div></div><button onClick={(e) => {e.stopPropagation(); onVisitProfile(u.authUid);}} className="text-cyan-400 p-2 rounded-full hover:bg-gray-700 transition"><UserPlus size={18}/></button></div>))}</div></>)}
            </div>);
        };

        const InboxView = ({ user, onOpenChat, notifications, chats, onlineStatus }) => {
             const [tab, setTab] = useState('chats'); 
             const allUsers = chats.reduce((acc, chat) => { const otherUid = chat.participants.find(uid => uid !== user.uid); if (otherUid && chat.participantsData?.[otherUid]) { acc[otherUid] = { uid: otherUid, ...chat.participantsData[otherUid] }; } return acc; }, {}); 
             const myChats = chats.filter(c => c.status === 'accepted'); 
             const requests = chats.filter(c => c.status === 'pending' && c.participants.includes(user?.uid)); 
             // Unificando perfil en aceptacion de chat
             const handleAccept = async (chatId, targetUid) => { if (!user?.uid) return; await updateDoc(doc(db, 'artifacts', appId, 'chats', chatId), { status: 'accepted', targetId: null }); const q = query(collection(db, "users"), where("authUid", "==", user.uid)); const s = await getDocs(q); const userData = s.docs[0].data(); const otherUser = allUsers[targetUid]; await addDoc(collection(db, 'artifacts', appId, 'users', targetUid, 'notifications'), { type: 'message_accept', fromUser: user.uid, fromName: userData.username, avatar: userData.profilePicture, createdAt: new Date().toISOString() }); onOpenChat(chatId, otherUser); };
            
            return (<div className="w-full h-full bg-gray-900 pt-4 px-4 overflow-y-auto pb-24 flex flex-col">
                <div className="flex gap-4 mb-6 border-b border-gray-800 pb-2"><button onClick={() => setTab('chats')} className={`text-sm font-bold pb-2 ${tab==='chats'?'text-white border-b-2 border-white':'text-gray-500'}`}>Mensajes</button><button onClick={() => setTab('requests')} className={`text-sm font-bold pb-2 ${tab==='requests'?'text-white border-b-2 border-white':'text-gray-500'}`}>Solicitudes {requests.length > 0 && <span className="text-red-500">({requests.length})</span>}</button></div>
                <div className="space-y-2 flex-1">
                    {tab === 'chats' ? (myChats.length === 0 ? <div className="text-center text-gray-500 mt-10">No tienes mensajes</div> : myChats.map(chat => { const otherUid = chat.participants.find(uid => uid !== user.uid); const otherUser = allUsers[otherUid]; const otherName = otherUser?.displayName || "Usuario"; const otherImg = otherUser?.photoURL || `https://api.dicebear.com/7.x/avataaars/svg?seed=${otherUid}`; const isStreakActive = chat.streak && chat.streak.count > 0 && (new Date().getTime() - new Date(chat.streak.lastMessageTime).getTime() < 86400000); const isOnline = onlineStatus[otherUid]?.online || false; const unreadCount = getUnreadCountForChat(chat, user.uid); return (<div key={chat.id} onClick={() => onOpenChat(chat.id, otherUser)} className="flex items-center gap-3 p-3 bg-gray-800/40 rounded-xl border border-gray-800 cursor-pointer hover:bg-gray-800"><div className="w-12 h-12 rounded-full bg-gray-700 overflow-hidden border border-gray-600 flex-shrink-0 relative"><img src={otherImg} className="w-full h-full object-cover"/>{isOnline && (<div className="absolute bottom-0 right-0 w-3 h-3 bg-green-500 rounded-full border-2 border-gray-900"></div>)}{unreadCount > 0 && (<div className="absolute top-0 right-0 w-5 h-5 bg-red-600 rounded-full flex items-center justify-center text-xs font-bold text-white border-2 border-gray-900">{unreadCount}</div>)}</div><div className="flex-1"><p className="font-bold text-white flex items-center gap-2">{otherName} {isStreakActive && (<div className="flex items-center gap-0.5"><img src={STREAK_GIF_URL} alt="Racha" className="w-5 h-5"/><span className="text-yellow-400 text-xs font-extrabold">x{chat.streak.count}</span></div>)}</p><p className="text-xs text-gray-400">Toca para chatear</p></div></div>) })) : (requests.length === 0 ? <div className="text-center text-gray-500 mt-10">No tienes solicitudes</div> : requests.map(req => { const senderUid = req.participants.find(uid => uid !== user.uid); const senderUser = allUsers[senderUid]; const senderName = senderUser?.displayName || "Usuario"; return (<div key={req.id} className="flex items-center gap-3 p-3 bg-gray-800/40 rounded-xl border border-gray-800"><div className="flex-1"><p className="font-bold text-white">Solicitud de {senderName}</p><p className="text-xs text-gray-400">Quiere chatear contigo</p></div><button onClick={() => handleAccept(req.id, senderUid)} className="px-4 py-2 bg-white text-black rounded-lg text-xs font-bold">Aceptar</button></div>) }))}
                </div>
            </div>);
        };

        const ChatScreen = ({ chatId, user, onClose, videos, chatData, otherUser }) => {
            const [messages, setMessages] = useState([]);
            const [txt, setTxt] = useState("");
            const [file, setFile] = useState(null);
            const [preview, setPreview] = useState(null); 
            const [replyTo, setReplyTo] = useState(null);
            const [isTyping, setIsTyping] = useState(false);
            const [showStickerModal, setShowStickerModal] = useState(false); 
            const [showGameInviteModal, setShowGameInviteModal] = useState(false); 
            const endRef = useRef(null);
            const [isRecording, setIsRecording] = useState(false);
            const mediaRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);
            const typingTimerRef = useRef(null);
            
            // Perfil unificado
            const currentUserProfile = useUnifiedProfile(user?.uid);
            
            const markAsRead = useCallback(async () => { if (!user?.uid || !chatId) return; const chatRef = doc(db, 'artifacts', appId, 'chats', chatId); await updateDoc(chatRef, { [`participantsData.${user.uid}.lastRead`]: new Date().toISOString() }); }, [user?.uid, chatId]);
            useEffect(() => { if(!chatId) return; const q = query(collection(db, 'artifacts', appId, 'chats', chatId, 'messages'), orderBy('createdAt', 'desc')); const unsub = onSnapshot(q, s => { setMessages(s.docs.map(d => ({id: d.id, ...d.data(), chatId}))); markAsRead(); }); markAsRead(); return () => unsub(); }, [chatId, markAsRead]);
            useEffect(() => { if (endRef.current) { endRef.current.scrollIntoView({ behavior: 'smooth' }); } }, [messages.length, chatId]); 
            useEffect(() => { if(!chatId) return; const chatRef = doc(db, 'artifacts', appId, 'chats', chatId); return onSnapshot(chatRef, (snap) => { const typingUser = snap.data().typing; setIsTyping(typingUser && typingUser !== user?.uid); }); }, [chatId]);
            
            const setTypingStatus = (status) => { const chatRef = doc(db, 'artifacts', appId, 'chats', chatId); updateDoc(chatRef, { typing: status ? user?.uid : null }).catch(console.error); };
            const handleTextChange = (e) => { setTxt(e.target.value); e.target.style.height = 'auto'; e.target.style.height = e.target.scrollHeight + 'px'; if (e.target.value.length > 0) { if (!typingTimerRef.current) setTypingStatus(true); clearTimeout(typingTimerRef.current); typingTimerRef.current = setTimeout(() => { setTypingStatus(false); typingTimerRef.current = null; }, 3000); } else { clearTimeout(typingTimerRef.current); setTypingStatus(false); typingTimerRef.current = null; } };
            useEffect(() => { return () => { clearTimeout(typingTimerRef.current); if (auth.currentUser) setTypingStatus(false); }; }, [chatId]);
            const updateStreak = async (lastMessageTime) => { if (!user?.uid) return; const chatRef = doc(db, 'artifacts', appId, 'chats', chatId); const snap = await getDoc(chatRef); if (!snap.exists()) return; const chatData = snap.data(); const now = new Date(lastMessageTime).getTime(); const lastTime = chatData.streak ? new Date(chatData.streak.lastMessageTime).getTime() : 0; const lastSender = chatData.streak ? chatData.streak.lastSenderId : null; const currentCount = chatData.streak ? chatData.streak.count : 0; const isWithin24Hours = (now - lastTime) < 86400000; const streakLost = (now - lastTime) >= 86400000; let newCount = currentCount; if (currentCount === 0) { newCount = 1; } else if (isWithin24Hours && lastSender !== user.uid) { newCount = currentCount + 1; } else if (streakLost) { newCount = 1; } else if (lastSender === user.uid) { newCount = currentCount; } await updateDoc(chatRef, { streak: { count: newCount, lastMessageTime: new Date(lastMessageTime).toISOString(), lastSenderId: user.uid }, lastMessageTime: new Date(lastMessageTime).toISOString(), lastSenderId: user.uid }); };
            const updateMessageAudioUrl = async (messageId, newUrl) => { const messageRef = doc(db, 'artifacts', appId, 'chats', chatId, 'messages', messageId); await updateDoc(messageRef, { fileUrl: newUrl, type: 'audio_tts' }); };

            const sendMessage = async (type, content, extraData = {}) => {
                if (!user?.uid) return; 
                const messageTime = new Date().toISOString();
                const message = { type, senderId: user.uid, createdAt: messageTime, ...(type === 'text' || type === 'audio_tts' ? { text: content } : { fileUrl: content }), ...extraData, ...(replyTo ? { replyTo: { text: replyTo.text, type: replyTo.type, senderId: replyTo.senderId } } : {}), };
                await addDoc(collection(db, 'artifacts', appId, 'chats', chatId, 'messages'), message);
                await updateStreak(messageTime); setTypingStatus(false); 
                const chatDoc = await getDoc(doc(db, 'artifacts', appId, 'chats', chatId));
                const participants = chatDoc.data().participants;
                const receiverId = participants.find(id => id !== user.uid);
                if (receiverId && currentUserProfile) { await addDoc(collection(db, 'artifacts', appId, 'users', receiverId, 'notifications'), { type: 'message', fromUser: user.uid, fromName: currentUserProfile.username, avatar: currentUserProfile.profilePicture, createdAt: messageTime }); }
            };
            
            const handleStickerSelect = (url) => { sendMessage('sticker', url); setShowStickerModal(false); };
            const handleSendGameInvite = (gameName, inviteLink, message) => { const data = { gameName, inviteLink, message }; sendMessage('game_invite', data); setShowGameInviteModal(false); };
            const sendTextOrAudio = () => { if(!txt.trim()) return; sendMessage('text', txt.trim()); setTxt(""); setReplyTo(null); };
            const handleFileSelect = (e) => { const selectedFile = e.target.files[0]; if (selectedFile) { setFile(selectedFile); setPreview(URL.createObjectURL(selectedFile)); } };
            const clearFile = () => { setFile(null); setPreview(null); };
            const sendFile = async () => { if (!user?.uid || !file) return; const fileName = file.name || "file.bin"; const fileExtension = fileName.split('.').pop().toLowerCase(); let fileType = 'file'; if (['png', 'jpg', 'jpeg', 'gif'].includes(fileExtension)) fileType = 'image'; else if (['mp3', 'wav', 'ogg', 'webm'].includes(fileExtension)) fileType = 'audio'; else if (['mp4', 'mov', 'avi'].includes(fileExtension)) fileType = 'video'; const path = `chats/${chatId}/${Date.now()}_${fileName.replace(/[^a-zA-Z0-9.]/g,'')}`; try { const url = await uploadToGitHub(file, path, (s) => console.log(s)); sendMessage(fileType, url, { fileType, text: txt }); } catch(e) { console.error("Error al subir archivo:", e.message); } finally { setFile(null); setPreview(null); setTxt(""); setReplyTo(null); } };
            const startRecording = async () => { if (isRecording || !user?.uid) return; try { const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); const options = { mimeType: 'audio/webm' }; const recorder = new MediaRecorder(stream, options); mediaRecorderRef.current = recorder; audioChunksRef.current = []; recorder.ondataavailable = (event) => { audioChunksRef.current.push(event.data); }; recorder.onstop = async () => { const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' }); const audioFile = new File([audioBlob], `audio_${Date.now()}.webm`, { type: 'audio/webm' }); const path = `chats/${chatId}/${Date.now()}_audio.webm`; const url = await uploadToGitHub(audioFile, path, (s) => console.log(s)); sendMessage('audio', url, { fileType: 'audio' }); stream.getTracks().forEach(track => track.stop()); }; recorder.start(); setIsRecording(true); } catch (err) { console.error('Error al acceder al micrófono:', err.message); setIsRecording(false); } };
            const stopRecording = () => { if (mediaRecorderRef.current && isRecording) { mediaRecorderRef.current.stop(); setIsRecording(false); } };
            const deleteMsg = async (msgId) => { await deleteDoc(doc(db, 'artifacts', appId, 'chats', chatId, 'messages', msgId)); };
            const handleKeyDown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); if (file) { sendFile(); } else if (txt.trim()) { sendTextOrAudio(); } } };
            const isSendButtonVisible = !!file || txt.trim().length > 0;

            return (
                <div className="absolute inset-0 z-50 bg-gray-900 flex flex-col animate-in slide-in-from-right h-[100dvh]">
                    <div className="p-4 bg-gray-900 border-b border-gray-800 flex items-center gap-3"><button onClick={onClose} className="p-2 rounded-full hover:bg-gray-800 transition"><ArrowLeft className="text-white"/></button><div className="flex items-center gap-2"><div className="w-8 h-8 rounded-full overflow-hidden flex-shrink-0"><img src={otherUser?.photoURL || `https://api.dicebear.com/7.x/avataaars/svg?seed=${otherUser?.uid}`} className="w-full h-full object-cover"/></div><span className="font-bold text-white text-lg">{otherUser?.displayName || "Chat Privado"}</span>{otherUser?.isVerified && <VerifiedBadge size={16} />}</div></div>
                    <div className="message-list-container"><div ref={endRef} /><div className="message-list-content">{messages.slice().reverse().map((m) => ( <MessageBubble key={m.id} message={m} isMe={m.senderId === user?.uid} onDelete={deleteMsg} onReply={setReplyTo} videos={videos} onUpdateAudioUrl={updateMessageAudioUrl} />))}</div></div>
                    {isTyping && (<div className="px-4 py-2"><div className="flex justify-start"><div className="max-w-[70%] p-3 rounded-2xl text-sm bg-gray-800 text-white flex items-center gap-2"><span className="text-gray-300 italic text-xs">Escribiendo</span><div className="typing-indicator"><span className="typing-dot"></span><span className="typing-dot"></span><span className="typing-dot"></span></div></div></div></div>)}
                    <div className="p-3 bg-gray-900 border-t border-gray-800 flex flex-col gap-2">
                        {replyTo && (<div className="flex items-center justify-between p-2 bg-gray-800 rounded-lg text-sm border-l-4 border-cyan-400"><span className="text-gray-300 italic truncate">Respondiendo a: {replyTo.text || replyTo.type}</span><button onClick={() => setReplyTo(null)} className="text-red-400 ml-2"><X size={16}/></button></div>)}
                        {file && (<div className="relative bg-gray-800 rounded-xl p-2 flex items-center gap-3 border border-gray-700 animate-in slide-in-from-bottom-2"><div className="w-12 h-12 bg-gray-700 rounded-lg overflow-hidden flex items-center justify-center flex-shrink-0">{file.type.startsWith('image/') ? (<img src={preview} className="w-full h-full object-cover" />) : file.type.startsWith('video/') ? (<video src={preview} className="w-full h-full object-cover" />) : (<Paperclip size={20} className="text-gray-400" />)}</div><div className="flex-1 min-w-0"><p className="text-sm text-white truncate font-medium">{file.name}</p><p className="text-xs text-gray-400">{(file.size / 1024 / 1024).toFixed(2)} MB</p></div><button onClick={clearFile} className="p-1.5 bg-gray-700 rounded-full hover:bg-red-500/20 hover:text-red-500 transition"><X size={16} /></button></div>)}
                        <div className="flex gap-2 items-end"> 
                            <button onClick={() => setShowStickerModal(true)} className="w-10 h-10 bg-gray-800 rounded-full flex items-center justify-center text-white cursor-pointer hover:bg-gray-700 transition flex-shrink-0"><Smile size={20}/></button><button onClick={() => setShowGameInviteModal(true)} className="w-10 h-10 bg-gray-800 rounded-full flex items-center justify-center text-white cursor-pointer hover:bg-gray-700 transition flex-shrink-0"><Gamepad size={20} className="text-cyan-400"/></button><label className="w-10 h-10 bg-gray-800 rounded-full flex items-center justify-center text-white cursor-pointer hover:bg-gray-700 transition flex-shrink-0"><Paperclip size={18}/><input type="file" className="hidden" onChange={handleFileSelect} /></label>
                            <textarea value={txt} onChange={handleTextChange} className="chat-input flex-1 bg-gray-800 text-white p-3 rounded-2xl outline-none resize-none max-h-40" placeholder={file ? "Añade un comentario..." : "Mensaje..."} onKeyDown={handleKeyDown} disabled={isRecording} rows={1} />
                            <div className="flex flex-col gap-2 items-center flex-shrink-0">{isSendButtonVisible ? (<>{txt.trim() && txt.trim().length > 100 && !file && (<button onClick={sendTextOrAudio} className="w-10 h-10 bg-cyan-600 rounded-full text-white hover:bg-cyan-500 transition shadow-lg flex items-center justify-center" title="Enviar como Audio (TTS)"><Mic size={18}/></button>)}<button onClick={file ? () => sendFile() : sendTextOrAudio} className="w-10 h-10 p-2 bg-white rounded-full text-black flex items-center justify-center hover:bg-gray-200 transition shadow-lg"><Send size={18}/></button></>) : (<button onMouseDown={startRecording} onMouseUp={stopRecording} onTouchStart={startRecording} onTouchEnd={stopRecording} className={`w-10 h-10 p-2 rounded-full transition-all flex items-center justify-center shadow-lg ${isRecording ? 'bg-red-500 scale-110 text-white' : 'bg-gray-800 text-white hover:bg-gray-700'}`}><Mic size={18}/></button>)}</div>
                        </div>
                    </div>
                    <StickerModal isOpen={showStickerModal} onClose={() => setShowStickerModal(false)} onSelectSticker={handleStickerSelect} /><GameInviteModal isOpen={showGameInviteModal} onClose={() => setShowGameInviteModal(false)} onSendInvite={handleSendGameInvite} />
                </div>
            );
        };

        const App = () => {
            const [user, setUser] = useState(null);
            const [isAuthReady, setIsAuthReady] = useState(false); 
            const [videos, setVideos] = useState([]);
            const [chats, setChats] = useState([]); 
            const [activeTab, setActiveTab] = useState('home');
            const [currentIndex, setCurrentIndex] = useState(0);
            const [showUpload, setShowUpload] = useState(false);
            const [showShare, setShowShare] = useState(null); 
            const [viewingProfile, setViewingProfile] = useState(null);
            const [activeChatId, setActiveChatId] = useState(null);
            const [chatOtherUser, setChatOtherUser] = useState(null); 
            const [onlineStatus, setOnlineStatus] = useState({}); 
            const [commentsVideo, setCommentsVideo] = useState(null); 
            const [feedMode, setFeedMode] = useState('global');
            const [profileFeedVideos, setProfileFeedVideos] = useState([]);
            const [notifications, setNotifications] = useState([]);
            const [latestToast, setLatestToast] = useState(null);
            // Perfil unificado
            const userProfile = useUnifiedProfile(user?.uid);
            
            const feedRef = useRef(null);
            
            const setupPresence = (uid) => {
                const isOnlineRef = doc(db, 'artifacts', appId, 'public', 'data', 'status', uid);
                const setOnline = async () => { await setDoc(isOnlineRef, { online: true, last_seen: serverTimestamp() }); };
                const setOffline = async () => { await setDoc(isOnlineRef, { online: false, last_seen: serverTimestamp() }, { merge: true }); };
                setOnline();
                window.addEventListener('beforeunload', setOffline);
                return () => { window.removeEventListener('beforeunload', setOffline); };
            };

            useEffect(() => {
                const unsubAuth = onAuthStateChanged(auth, (currentUser) => {
                    setUser(currentUser);
                    setIsAuthReady(true);
                    if (currentUser && !currentUser.isAnonymous) { setupPresence(currentUser.uid); }
                });
                return () => unsubAuth();
            }, []); 

            useEffect(() => {
                if(!user || !isAuthReady) return; 
                
                const unsubscribers = [];
                
                unsubscribers.push(onSnapshot(query(collection(db, 'artifacts', appId, 'public', 'data', 'videos'), orderBy('createdAt', 'desc')), s => setVideos(s.docs.map(d => ({id: d.id, ...d.data()})))));
                
                unsubscribers.push(onSnapshot(query(collection(db, 'artifacts', appId, 'chats'), where('participants', 'array-contains', user.uid)), s => setChats(s.docs.map(d => ({id: d.id, ...d.data()})))));
                
                const qNotifs = query(collection(db, 'artifacts', appId, 'users', user.uid, 'notifications'), orderBy('createdAt', 'desc'), limit(10));
                unsubscribers.push(onSnapshot(qNotifs, (snapshot) => {
                    const notifs = snapshot.docs.map(d => ({id: d.id, ...d.data()}));
                    if (notifs.length > 0) {
                        const newest = notifs[0];
                        const now = new Date().getTime();
                        const notifTime = new Date(newest.createdAt).getTime();
                        if (now - notifTime < 10000) {
                            setLatestToast(newest);
                        }
                    }
                    setNotifications(notifs);
                }));

                unsubscribers.push(onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', 'status'), (snapshot) => {
                    const statusMap = {};
                    snapshot.docs.forEach(doc => {
                        statusMap[doc.id] = doc.data();
                    });
                    setOnlineStatus(statusMap);
                }));
                
                return () => unsubscribers.forEach(unsub => unsub());
            }, [user, isAuthReady]); 

            const handleScroll = () => {
                if (feedRef.current && activeTab === 'home') {
                const idx = Math.round(feedRef.current.scrollTop / feedRef.current.clientHeight);
                if (idx !== currentIndex) setCurrentIndex(idx);
                }
            };

            const toggleLike = async (video, likerId) => {
                if (!likerId) return; 
                const likeRef = doc(db, 'artifacts', appId, 'public', 'data', 'videos', video.id, 'likes', likerId);
                const likeSnap = await getDoc(likeRef);

                if (likeSnap.exists()) {
                    return; 
                } else {
                    await setDoc(likeRef, { userId: likerId, createdAt: new Date().toISOString() });
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'videos', video.id), { likes: increment(1) });
                    
                    if(video.authorId !== likerId) { 
                        // Intentar obtener datos del usuario unificado
                        const q = query(collection(db, "users"), where("authUid", "==", likerId), limit(1));
                        const s = await getDocs(q);
                        
                        // Fallback a artifacts si no existe en users (para usuarios antiguos)
                        let uData;
                        if (!s.empty) {
                            uData = s.docs[0].data();
                        } else {
                            const oldDoc = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', likerId));
                            uData = oldDoc.exists() ? oldDoc.data() : { username: 'Usuario', profilePicture: null };
                        }

                        // Buscar dónde notificar (usuario antiguo vs nuevo)
                        // Por compatibilidad, seguimos usando artifacts para notificaciones
                        await addDoc(collection(db, 'artifacts', appId, 'users', video.authorId, 'notifications'), {
                            type: 'like', 
                            fromUser: likerId, 
                            fromName: uData.username || uData.displayName, 
                            avatar: uData.profilePicture || uData.photoURL, 
                            thumbnail: video.url, 
                            createdAt: new Date().toISOString()
                        });
                    }
                }
            };
            
            const goToProfile = (uid) => {
                setViewingProfile(uid);
                setActiveTab('profile');
            };

            const openProfileVideo = (video) => {
                let targetVid = video;
                if (!targetVid.id) targetVid = videos.find(v => v.id === video);

                const userVids = videos.filter(v => v.authorId === targetVid.authorId);
                const idx = userVids.findIndex(v => v.id === targetVid.id);
                
                setProfileFeedVideos(userVids);
                setFeedMode('profile');
                setActiveTab('home');
                setTimeout(() => {
                    setCurrentIndex(idx);
                    feedRef.current?.scrollTo({top: idx * feedRef.current.clientHeight, behavior: 'auto'});
                }, 50);
            };

            const goHome = () => {
                setFeedMode('global');
                setActiveTab('home');
                setViewingProfile(null);
            };
            
            const openChat = (chatId, otherUser) => {
                setActiveChatId(chatId);
                setChatOtherUser(otherUser);
            }
            
            const openComments = (video) => {
                setCommentsVideo(video);
            };
            
            const closeComments = () => {
                setCommentsVideo(null);
            };

            const startChat = async (targetUid, targetProfile) => {
                if (!user?.uid) return; 
                
                const chatId = getChatId(user.uid, targetUid);
                const chatRef = doc(db, 'artifacts', appId, 'chats', chatId);
                const chatSnap = await getDoc(chatRef);

                if (chatSnap.exists()) {
                    if (chatSnap.data().status === 'accepted') {
                        openChat(chatId, { uid: targetUid, ...targetProfile });
                    } else {
                        console.log("Solicitud pendiente...");
                    }
                } else {
                    await setDoc(chatRef, {
                        participants: [user.uid, targetUid],
                        participantsData: {
                            [user.uid]: { displayName: user.displayName || "Usuario", photoURL: user.photoURL },
                            [targetUid]: { displayName: targetProfile.displayName || "Usuario", photoURL: targetProfile.photoURL }
                        },
                        status: 'pending',
                        createdAt: new Date().toISOString()
                    });
                    console.log("Solicitud enviada");
                }
            };

            const currentFeedVideos = feedMode === 'global' ? videos : profileFeedVideos;

            if (!isAuthReady) {
                return (
                    <div className="flex flex-col items-center justify-center h-screen bg-gray-950 text-white">
                        <Loader2 className="animate-spin text-white/50" size={32}/>
                        <p className="mt-4 text-gray-500">Cargando autenticación...</p>
                    </div>
                );
            }

            if(!user) return <AuthScreen />;

            return (
                <div className="flex justify-center bg-black h-[100dvh] w-full font-sans text-white select-none">
                <ToastNotification notif={latestToast} onClose={() => setLatestToast(null)} />
                
                <div className="relative w-full max-w-md h-full bg-gray-900 shadow-[0_0_40px_rgba(0,0,0,0.5)] flex flex-col border-x border-gray-800 overflow-hidden">
                    
                    {/* Contenedor principal de vistas que debe manejar el desplazamiento */}
                    <div className={`flex-1 flex flex-col ${activeTab === 'home' ? 'overflow-hidden' : 'overflow-y-auto'}`}> 
                    
                        {/* Encabezado fijo superior para la navegación principal */}
                        <div className="absolute top-0 w-full p-4 pt-8 z-30 flex justify-center gap-4 bg-gradient-to-b from-gray-900/80 to-transparent pointer-events-none backdrop-blur-[1px]">
                            
                            {activeTab === 'home' && (
                                <>
                                    {/* NUEVO: Botón Live */}
                                    <a 
                                        href="https://www.livepayout.org/" 
                                        target="_blank" 
                                        rel="noopener noreferrer"
                                        className="font-bold text-base cursor-pointer pointer-events-auto text-red-500 border-b-2 border-red-500 pb-1"
                                    >
                                        LIVE
                                    </a>

                                    <span className={`font-bold text-base cursor-pointer pointer-events-auto ${feedMode==='profile'?'text-gray-400':'text-white border-b-2 border-white pb-1'}`} onClick={goHome}>Para Ti</span>
                                    {feedMode === 'profile' && <span className="font-bold text-white border-b-2 pointer-events-auto pb-1">Viendo Perfil</span>}
                                </>
                            )}
                        </div>

                        {activeTab === 'home' && (
                            <div 
                                ref={feedRef} 
                                onScroll={handleScroll} 
                                className="flex-1 overflow-y-scroll snap-y snap-mandatory no-scrollbar bg-gray-900 pt-[60px]" // Espacio para el encabezado
                            >
                                {currentFeedVideos.length > 0 ? currentFeedVideos.map((v, i) => (
                                    <VideoPlayer 
                                        key={v.id} 
                                        video={v} 
                                        isActive={i === currentIndex && activeTab === 'home'} 
                                        toggleLike={toggleLike} 
                                        onShare={(id) => setShowShare(id)} 
                                        onVisitProfile={goToProfile}
                                        onOpenComments={openComments} 
                                        userProfile={userProfile} 
                                    />
                                )) : <div className="h-full flex items-center justify-center"><Loader2 className="animate-spin text-white/50"/></div>}
                            </div>
                        )}

                        {/* Las vistas que manejan su propio scroll deben tener un padding/margen superior si se comparte el encabezado,
                           pero como lo hemos ocultado, solo necesitan la clase h-full */}

                        {activeTab === 'trends' && <TrendsView videos={videos} onVideoClick={openProfileVideo} onVisitProfile={goToProfile} />}

                        {activeTab === 'profile' && (
                            <ProfileView 
                                targetUserId={viewingProfile || user.uid} 
                                currentUser={user} 
                                videos={videos} 
                                onBack={() => {
                                    if(feedMode === 'profile') setActiveTab('home');
                                    else { setViewingProfile(null); setActiveTab('home'); }
                                }} 
                                onVideoClick={(id) => openProfileVideo({id, authorId: viewingProfile || user.uid})}
                                onLogout={() => signOut(auth)}
                                onChat={startChat}
                            />
                        )}

                        {activeTab === 'inbox' && (
                            <InboxView user={user} onOpenChat={openChat} notifications={notifications} chats={chats} onlineStatus={onlineStatus} />
                        )}
                    
                    </div> {/* Fin del contenedor flex-1 */}

                    <div className="bg-gray-900/95 border-t border-gray-500 p-2 flex justify-around items-center z-40 pb-5 backdrop-blur-xl h-[80px]">
                        <button onClick={goHome} className={`flex flex-col items-center gap-1 w-14 cursor-pointer transition active:scale-90 ${activeTab==='home'?'opacity-100':'opacity-50 hover:opacity-100'}`}><Home size={26} strokeWidth={activeTab==='home'?3:2} className="text-white fill-white"/><span className="text-[10px] font-medium text-white">Inicio</span></button>
                        <button onClick={() => setActiveTab('trends')} className={`flex flex-col items-center gap-1 w-14 cursor-pointer transition active:scale-90 ${activeTab==='trends'?'opacity-100':'opacity-50 hover:opacity-100'}`}><img src={ICONS.tendencia} className="w-7 h-7 invert"/><span className="text-[10px] font-medium text-white">Tendencias</span></button>
                        
                        <button onClick={() => setShowUpload(true)} className="relative -top-1 cursor-pointer group mx-2">
                            <div className="absolute inset-0 bg-white/20 rounded-xl blur-md group-hover:blur-lg transition duration-300 opacity-50"></div>
                            <div className="relative bg-white w-14 h-9 rounded-xl flex items-center justify-center group-hover:scale-105 transition-transform duration-200 border border-gray-200">
                                <img src={ICONS.crear} className="w-6 h-6"/>
                            </div>
                        </button>

                        <button onClick={()=>setActiveTab('inbox')} className={`flex flex-col items-center gap-1 w-14 cursor-pointer transition active:scale-90 ${activeTab==='inbox'?'opacity-100':'opacity-50 hover:opacity-100'} relative`}>
                            <img src={ICONS.bandeja} className="w-7 h-7 invert"/>
                            <span className="text-[10px] font-medium text-white">Bandeja</span>
                            {getUnreadMessagesCount(chats, user.uid) > 0 && (
                                <span className="absolute top-0 right-3 w-4 h-4 bg-red-600 rounded-full flex items-center justify-center text-[10px] font-bold text-white border-2 border-black">
                                    {getUnreadMessagesCount(chats, user.uid)}
                                </span>
                            )}
                        </button>
                        <button onClick={()=>{setViewingProfile(null); setActiveTab('profile')}} className={`flex flex-col items-center gap-1 w-14 cursor-pointer transition active:scale-90 ${activeTab==='profile'?'opacity-100':'opacity-50 hover:opacity-100'}`}><img src={ICONS.perfil} className="w-7 h-7 invert"/>
                            <span className="text-[10px] font-medium text-white">Perfil</span>
                        </button>
                    </div>

                    <UploadModal isOpen={showUpload} onClose={() => setShowUpload(false)} user={user} />
                    <ShareVideoModal isOpen={!!showShare} onClose={() => setShowShare(null)} videoId={showShare} user={user} chats={chats} />
                    {/* CRÍTICO: Pasamos userProfile al CommentsModal */}
                    <CommentsModal isOpen={!!commentsVideo} onClose={closeComments} video={commentsVideo} user={user} userProfile={userProfile} />
                    
                    {activeChatId && <ChatScreen chatId={activeChatId} user={user} onClose={() => setActiveChatId(null)} videos={videos} otherUser={chatOtherUser} />}
                    
                </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>



